<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-12T03:21:34.585Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/07/12/hello-world/"/>
    <id>http://example.com/2021/07/12/hello-world/</id>
    <published>2021-07-12T03:21:34.585Z</published>
    <updated>2021-07-12T03:21:34.585Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>[面试复习]Java虚拟机(jvm)</title>
    <link href="http://example.com/2021/06/07/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0-Java%E8%99%9A%E6%8B%9F%E6%9C%BA-jvm/"/>
    <id>http://example.com/2021/06/07/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0-Java%E8%99%9A%E6%8B%9F%E6%9C%BA-jvm/</id>
    <published>2021-06-07T02:03:23.000Z</published>
    <updated>2021-06-07T02:14:53.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Java内存区域"><a href="#一、Java内存区域" class="headerlink" title="一、Java内存区域"></a>一、Java内存区域</h2><h3 id="1-说一下JVM的主要组成部分以及作用？"><a href="#1-说一下JVM的主要组成部分以及作用？" class="headerlink" title="1. 说一下JVM的主要组成部分以及作用？"></a>1. 说一下JVM的主要组成部分以及作用？</h3><ul><li><p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p><ul><li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li><li>Execution engine(执行引擎)：执行classes中的指令。</li><li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li><li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li></ul></li><li><p>作用 ：首先通过编译器把Java代码转换成字节码，类加载器再把字节码加载到内存中，将其放在运行时数据区的方法区内，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎，将字节码翻译成底层系统指令，再交由CPU去执行，而这个过程中需要调用其他语言的本地库接口来实现整个程序的功能。</p></li><li><p>其实可以一句话来解释：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</p></li></ul><h3 id="2-说一下-JVM-运行时数据区"><a href="#2-说一下-JVM-运行时数据区" class="headerlink" title="2. 说一下 JVM 运行时数据区"></a>2. 说一下 JVM 运行时数据区</h3><ul><li><strong>Java 虚拟机在执行Java程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域</strong>。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：<ul><li>程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。</li><li>Java虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>本地方法栈：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务Java方法的，而本地方法栈是为虚拟机调用Native方法服务的。</li><li>Java堆：Java虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存。</li><li>方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li></ul></li></ul><h3 id="3-深拷贝和浅拷贝"><a href="#3-深拷贝和浅拷贝" class="headerlink" title="3. 深拷贝和浅拷贝"></a>3. 深拷贝和浅拷贝</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Java内存区域&quot;&gt;&lt;a href=&quot;#一、Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;一、Java内存区域&quot;&gt;&lt;/a&gt;一、Java内存区域&lt;/h2&gt;&lt;h3 id=&quot;1-说一下JVM的主要组成部分以及作用？&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>什么是BSD协议？</title>
    <link href="http://example.com/2021/05/31/%E4%BB%80%E4%B9%88%E6%98%AFBSD%E5%8D%8F%E8%AE%AE%EF%BC%9F/"/>
    <id>http://example.com/2021/05/31/%E4%BB%80%E4%B9%88%E6%98%AFBSD%E5%8D%8F%E8%AE%AE%EF%BC%9F/</id>
    <published>2021-05-31T05:07:11.000Z</published>
    <updated>2021-07-12T13:29:14.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是BSD协议？"><a href="#什么是BSD协议？" class="headerlink" title="什么是BSD协议？"></a>什么是BSD协议？</h1><ul><li><p>BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ul></li><li><p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。</p></li><li><p>很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p></li></ul>]]></content>
    
    
    <summary type="html">什么是BSD协议？</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="杂学" scheme="http://example.com/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SSM——SpringMVC(1)</title>
    <link href="http://example.com/2021/05/29/SSM%E2%80%94%E2%80%94SpringMVC-1/"/>
    <id>http://example.com/2021/05/29/SSM%E2%80%94%E2%80%94SpringMVC-1/</id>
    <published>2021-05-28T22:59:42.000Z</published>
    <updated>2021-05-29T05:45:10.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSM——SpringMVC-1"><a href="#SSM——SpringMVC-1" class="headerlink" title="SSM——SpringMVC(1)"></a>SSM——SpringMVC(1)</h1><h2 id="一、Spring与Web环境集成"><a href="#一、Spring与Web环境集成" class="headerlink" title="一、Spring与Web环境集成"></a>一、Spring与Web环境集成</h2><h3 id="1-1-ApplicationContext应用上下文获取方式"><a href="#1-1-ApplicationContext应用上下文获取方式" class="headerlink" title="1.1 ApplicationContext应用上下文获取方式"></a>1.1 ApplicationContext应用上下文获取方式</h3><ul><li>应用上下文对象是通过<code>new ClasspathXmlApplicationContext</code>(spring配置文件)方式获取的，但是每次从容器中获得Bean时都要编写<code>new ClasspathXmlApplicationContext</code>(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。</li><li>在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。</li></ul><h3 id="1-2-Spring提供获取应用上下文的工具"><a href="#1-2-Spring提供获取应用上下文的工具" class="headerlink" title="1.2 Spring提供获取应用上下文的工具"></a>1.2 Spring提供获取应用上下文的工具</h3><ul><li><p>上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。</p></li><li><p>所以我们需要做的只有两件事：</p><ul><li>在web.xml中配置ContextLoaderListener监听器(导入spring-web坐标)。</li><li>使用WebApplicationContextUtils获得应用上下文对象ApplicationContext。</li></ul></li><li><p>导入Spring集成web的坐标</p></li></ul><img src="https://pic.imgdb.cn/item/60b177e508f74bc1597902c5.jpg" style="zoom:67%;" /><ul><li>配置ContextLoaderListener监听器。</li></ul><img src="https://pic.imgdb.cn/item/60b1784c08f74bc1597d4d3d.jpg" style="zoom:67%;" /><ul><li>通过工具获得应用上下文对象。</li></ul><img src="https://pic.imgdb.cn/item/60b178a208f74bc15980cd39.jpg" style="zoom:67%;" /><h2 id="二、SpringMVC的简介"><a href="#二、SpringMVC的简介" class="headerlink" title="二、SpringMVC的简介"></a>二、SpringMVC的简介</h2><h3 id="2-1-SpringMVC概述"><a href="#2-1-SpringMVC概述" class="headerlink" title="2.1 SpringMVC概述"></a>2.1 SpringMVC概述</h3><ul><li>SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中。</li><li>SpringMVC已经成为目前最主流的MVC框架之一，并且随着Spring3.0的发布，全面超越Struts2，成为最优秀的MVC框架。它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。</li></ul><h3 id="2-3-SpringMVC快速入门"><a href="#2-3-SpringMVC快速入门" class="headerlink" title="2.3 SpringMVC快速入门"></a>2.3 SpringMVC快速入门</h3><ul><li><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。</p></li><li><p>开发步骤：</p><ul><li>导入SpringMVC相关坐标。</li><li>配置SpringMVC核心控制器DispathcerServlet。</li><li>创建Controller类和视图页面。</li><li>使用注解配置Controller类中业务方法的映射地址。</li><li>配置SpringMVC核心文件 spring-mvc.xml。</li><li>客户端发起请求测试。</li></ul></li><li><p>导入Spring和SpringMVC的坐标。</p></li></ul><img src="https://pic.imgdb.cn/item/60b179ca08f74bc1598d3503.jpg" style="zoom:67%;" /><ul><li>导入Servlet和Jsp的坐标。</li></ul><img src="https://pic.imgdb.cn/item/60b179ef08f74bc1598ed401.jpg" style="zoom:67%;" /><ul><li>在web.xml配置SpringMVC的核心控制器。</li></ul><img src="https://pic.imgdb.cn/item/60b17a2a08f74bc15991794a.jpg" style="zoom:67%;" /><ul><li>创建Controller和业务方法。</li></ul><img src="https://pic.imgdb.cn/item/60b17a5908f74bc15993854d.jpg" style="zoom:67%;" /><ul><li>创建视图页面index.jsp。</li></ul><img src="https://pic.imgdb.cn/item/60b17a7e08f74bc1599525bf.jpg" style="zoom:67%;" /><ul><li>配置注解。</li></ul><img src="https://pic.imgdb.cn/item/60b17aad08f74bc159975ce5.jpg" style="zoom:80%;" /><ul><li>创建spring-mvc.xml。</li></ul><img src="https://pic.imgdb.cn/item/60b17ae008f74bc15999c094.jpg" style="zoom:67%;" /><ul><li>SpringMVC流程图。</li></ul><p><img src="https://pic.imgdb.cn/item/60b1d12408f74bc1597f429c.jpg"></p><h2 id="三、SpringMVC的组件解析"><a href="#三、SpringMVC的组件解析" class="headerlink" title="三、SpringMVC的组件解析"></a>三、SpringMVC的组件解析</h2><h3 id="3-1-SpringMVC执行流程"><a href="#3-1-SpringMVC执行流程" class="headerlink" title="3.1 SpringMVC执行流程"></a>3.1 SpringMVC执行流程</h3><img src="https://pic.imgdb.cn/item/60b1d17408f74bc15983a1d4.jpg" style="zoom:80%;" /><ul><li>用户发送请求至前端控制器DispatcherServlet。</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet调用HandlerAdapter处理器适配器。</li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView。</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li><li>ViewReslover解析后返回具体View。</li><li>DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)。DispatcherServlet响应用户。</li></ul><h3 id="3-2-SpringMVC组件解析"><a href="#3-2-SpringMVC组件解析" class="headerlink" title="3.2 SpringMVC组件解析"></a>3.2 SpringMVC组件解析</h3><img src="https://pic.imgdb.cn/item/60b1d24208f74bc1598f0ebb.jpg" style="zoom:67%;" /><h3 id="3-3-SpringMVC注解解析"><a href="#3-3-SpringMVC注解解析" class="headerlink" title="3.3 SpringMVC注解解析"></a>3.3 SpringMVC注解解析</h3><img src="https://pic.imgdb.cn/item/60b1d30908f74bc1599a1223.jpg" style="zoom:67%;" /><h3 id="3-4-Spring-mvc配置解析"><a href="#3-4-Spring-mvc配置解析" class="headerlink" title="3.4 Spring-mvc配置解析"></a>3.4 Spring-mvc配置解析</h3><img src="https://pic.imgdb.cn/item/60b1d37b08f74bc159a09657.jpg" style="zoom:67%;" /><ul><li>视图解析器：SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址<code>org/springframework/web/servlet/DispatcherServlet.properties</code>，该文件中配置了默认的视图解析器，如下。</li></ul><p><img src="https://pic.imgdb.cn/item/60b1d47208f74bc159adcedd.jpg"></p><ul><li>翻看该解析器源码，可以看到该解析器的默认设置，如下。</li></ul><img src="https://pic.imgdb.cn/item/60b1d48e08f74bc159af4d5b.jpg" style="zoom:67%;" /><ul><li>我们可以通过属性注入的方式修改视图的的前后缀。</li></ul><img src="https://pic.imgdb.cn/item/60b1d4b008f74bc159b11718.jpg" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">SSM——SpringMVC(1)</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringMVC" scheme="http://example.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SSM——Spring(2)</title>
    <link href="http://example.com/2021/05/28/SSM%E2%80%94%E2%80%94Spring-2/"/>
    <id>http://example.com/2021/05/28/SSM%E2%80%94%E2%80%94Spring-2/</id>
    <published>2021-05-28T06:10:47.000Z</published>
    <updated>2021-05-28T09:13:06.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSM——Spring-2"><a href="#SSM——Spring-2" class="headerlink" title="SSM——Spring(2)"></a>SSM——Spring(2)</h1><h2 id="一、Spring配置数据源"><a href="#一、Spring配置数据源" class="headerlink" title="一、Spring配置数据源"></a>一、Spring配置数据源</h2><h3 id="1-1-数据源-连接池-的作用"><a href="#1-1-数据源-连接池-的作用" class="headerlink" title="1.1 数据源(连接池)的作用"></a>1.1 数据源(连接池)的作用</h3><ul><li><p>数据源(连接池)是提高程序性能如出现的。</p></li><li><p>事先实例化数据源，初始化部分连接资源。</p></li><li><p>使用连接资源时从数据源中获取。</p></li><li><p>使用完毕后将连接资源归还给数据源。</p></li><li><p>常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等。</p></li></ul><h3 id="1-2-数据源的开发步骤"><a href="#1-2-数据源的开发步骤" class="headerlink" title="1.2 数据源的开发步骤"></a>1.2 数据源的开发步骤</h3><ul><li>导入数据源的坐标和数据库驱动坐标。</li><li>创建数据源对象。</li><li>设置数据源的基本连接数据。</li><li>使用数据源获取连接资源和归还连接资源。</li><li>导入c3p0和druid的坐标。</li></ul><img src="https://pic.imgdb.cn/item/60b0ac3408f74bc159f8c66d.jpg" style="zoom:67%;" /><ul><li>导入MySQL数据库驱动坐标。</li></ul><img src="https://pic.imgdb.cn/item/60b0ac5908f74bc159fa4b89.jpg" style="zoom:67%;" /><ul><li>创建C3P0连接池。</li></ul><img src="https://pic.imgdb.cn/item/60b0ac8408f74bc159fc0a43.jpg" style="zoom:67%;" /><ul><li>创建Druid连接池。</li></ul><img src="https://pic.imgdb.cn/item/60b0acb408f74bc159fdf622.jpg" style="zoom:67%;" /><ul><li>提取jdbc.properties配置文件。</li></ul><img src="https://pic.imgdb.cn/item/60b0acdf08f74bc159ffaa73.jpg" style="zoom:67%;" /><ul><li>读取<code>jdbc.properties</code>配置文件创建连接池。</li></ul><img src="https://pic.imgdb.cn/item/60b0ad2008f74bc159025573.jpg" style="zoom:67%;" /><h3 id="1-3-Spring配置数据源"><a href="#1-3-Spring配置数据源" class="headerlink" title="1.3 Spring配置数据源"></a>1.3 Spring配置数据源</h3><ul><li>可以将DataSource的创建权交由Spring容器去完成。<ul><li>DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的。</li><li>DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入。</li></ul></li></ul><img src="https://pic.imgdb.cn/item/60b0adac08f74bc15907b633.jpg" style="zoom: 80%;" /><ul><li>测试从容器当中获取数据源。</li></ul><img src="https://pic.imgdb.cn/item/60b0ade008f74bc15909b01d.jpg" style="zoom:80%;" /><h3 id="1-4-抽取JDBC配置文件"><a href="#1-4-抽取JDBC配置文件" class="headerlink" title="1.4 抽取JDBC配置文件"></a>1.4 抽取JDBC配置文件</h3><ul><li><p><code>applicationContext.xml</code>加载<code>jdbc.properties</code>配置文件获得连接信息。</p></li><li><p>首先，需要引入context命名空间和约束路径：</p><ul><li>命名空间：<code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></li><li>约束路径：<code>http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</code>。</li></ul></li></ul><img src="https://pic.imgdb.cn/item/60b0ae8008f74bc1590fe3b4.jpg" style="zoom:67%;" /><h2 id="二、Spring注解开发"><a href="#二、Spring注解开发" class="headerlink" title="二、Spring注解开发"></a>二、Spring注解开发</h2><ul><li>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 </li><li>Spring原始注解主要是替代<code>&lt;Bean&gt;</code>的配置。</li></ul><img src="https://pic.imgdb.cn/item/60b0af1608f74bc15915fb4c.jpg" style="zoom:80%;" /><ul><li>使用注解进行开发时，需要在<code>applicationContext.xml</code>中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。</li></ul><img src="https://pic.imgdb.cn/item/60b0af6408f74bc159191938.jpg" style="zoom: 80%;" /><ul><li>使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。</li></ul><img src="https://pic.imgdb.cn/item/60b0af8f08f74bc1591ac812.jpg" style="zoom:67%;" /><ul><li>使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化，使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入。</li></ul><img src="https://pic.imgdb.cn/item/60b0afdc08f74bc1591ddb94.jpg" style="zoom:67%;" /><ul><li>使用@Value进行字符串的注入。</li></ul><img src="https://pic.imgdb.cn/item/60b0b02408f74bc15920ce05.jpg" style="zoom:67%;" /><ul><li>使用@Scope标注Bean的范围。</li></ul><img src="https://pic.imgdb.cn/item/60b0b05008f74bc15922a5d8.jpg" style="zoom:67%;" /><ul><li>使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法。</li></ul><img src="https://pic.imgdb.cn/item/60b0b07f08f74bc159248758.jpg" style="zoom:67%;" /><ul><li>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下。</li></ul><img src="https://pic.imgdb.cn/item/60b0b0c308f74bc15927486a.jpg" style="zoom: 80%;" /><img src="https://pic.imgdb.cn/item/60b0b0ff08f74bc159299a1e.jpg" style="zoom:67%;" /><ul><li>@Configuration和@ComponentScan和@Import。</li></ul><img src="https://pic.imgdb.cn/item/60b0b14708f74bc1592c53a5.jpg" style="zoom:67%;" /><ul><li>@PropertySource和@value。</li></ul><img src="https://pic.imgdb.cn/item/60b0b18d08f74bc1592ece2c.jpg" style="zoom:67%;" /><ul><li>@Bean。</li></ul><img src="https://pic.imgdb.cn/item/60b0b22608f74bc159341735.jpg" style="zoom:67%;" /><ul><li>测试加载核心配置类创建Spring容器。</li></ul><img src="https://pic.imgdb.cn/item/60b0b26f08f74bc15936a185.jpg" style="zoom:67%;" /><h2 id="三、Spring整合Junit"><a href="#三、Spring整合Junit" class="headerlink" title="三、Spring整合Junit"></a>三、Spring整合Junit</h2><h3 id="3-1-原始Junit测试Spring的问题"><a href="#3-1-原始Junit测试Spring的问题" class="headerlink" title="3.1 原始Junit测试Spring的问题"></a>3.1 原始Junit测试Spring的问题</h3><ul><li>在测试类中，每个测试方法都有以下两行代码。这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</li></ul><p><img src="https://pic.imgdb.cn/item/60b0b30108f74bc1593bd033.jpg"></p><h3 id="3-2-上述问题解决方法"><a href="#3-2-上述问题解决方法" class="headerlink" title="3.2 上述问题解决方法"></a>3.2 上述问题解决方法</h3><ul><li>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它。将需要进行测试Bean直接在测试类中进行注入。</li></ul><h3 id="3-3-Spring集成Junit步骤"><a href="#3-3-Spring集成Junit步骤" class="headerlink" title="3.3 Spring集成Junit步骤"></a>3.3 Spring集成Junit步骤</h3><img src="https://pic.imgdb.cn/item/60b0b35708f74bc1593ee522.jpg" style="zoom:80%;" /><ul><li>导入spring集成Junit的坐标。</li></ul><img src="https://pic.imgdb.cn/item/60b0b38408f74bc15940915d.jpg" style="zoom:67%;" /><ul><li>使用@Runwith注解替换原来的运行期。</li></ul><img src="https://pic.imgdb.cn/item/60b0b3a408f74bc15941c667.jpg" style="zoom:67%;" /><ul><li>使用@ContextConfiguration指定配置文件或配置类。</li></ul><img src="https://pic.imgdb.cn/item/60b0b3c908f74bc159432617.jpg" style="zoom:67%;" /><ul><li>使用@Autowired注入需要测试的对象。</li></ul><img src="https://pic.imgdb.cn/item/60b0b3f608f74bc15944d27a.jpg" style="zoom:67%;" /><ul><li>创建测试方法进行测试。</li></ul><img src="https://pic.imgdb.cn/item/60b0b41308f74bc15945ebe4.jpg" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">SSM——Spring(2)</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Spring5" scheme="http://example.com/tags/Spring5/"/>
    
  </entry>
  
  <entry>
    <title>SSM——Spring(1)</title>
    <link href="http://example.com/2021/05/28/SSM%E2%80%94%E2%80%94Spring-1/"/>
    <id>http://example.com/2021/05/28/SSM%E2%80%94%E2%80%94Spring-1/</id>
    <published>2021-05-28T04:45:20.000Z</published>
    <updated>2021-05-28T06:09:23.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSM——Spring-1"><a href="#SSM——Spring-1" class="headerlink" title="SSM——Spring(1)"></a>SSM——Spring(1)</h1><h2 id="一、Spring简介"><a href="#一、Spring简介" class="headerlink" title="一、Spring简介"></a>一、Spring简介</h2><ul><li>Spring是分层的Java SE/EE应用轻量级开源框架，以<strong>IoC</strong>(Inverse Of Control：反转控制)和<strong>AOP</strong>(Aspect Oriented Programming：面向切面编程)为内核。</li><li>提供了<strong>展现层SpringMVC</strong>和<strong>持久层Spring JDBCTemplate</strong>以及<strong>业务层事务管理</strong>等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。</li><li>Spring的优势如下。</li></ul><p><img src="https://pic.imgdb.cn/item/60b07c0a08f74bc159915558.jpg"></p><ul><li>Spring体系架构如下。</li></ul><img src="https://pic.imgdb.cn/item/60b07d2008f74bc159a2529b.jpg" style="zoom:67%;" /><h2 id="二、Spring快速入门"><a href="#二、Spring快速入门" class="headerlink" title="二、Spring快速入门"></a>二、Spring快速入门</h2><img src="https://pic.imgdb.cn/item/60b07d4608f74bc159a495dd.jpg" style="zoom:50%;" /><ul><li>Spring程序开发步骤：<ul><li>导入Spring开发的基本包坐标。</li><li>编写Dao接口和实现类。</li><li>创建Spring核心配置文件。</li><li>在Spring配置文件中配置UserDaoImpl。</li><li>使用Spring的API获得Bean实例。</li></ul></li><li>Spring开发的基本坐标</li></ul><img src="https://pic.imgdb.cn/item/60b07de008f74bc159ad72c1.jpg" style="zoom:67%;" /><ul><li>编写Dao接口和实现。</li></ul><img src="https://pic.imgdb.cn/item/60b07e1608f74bc159b0a083.jpg" style="zoom:67%;" /><ul><li>创建Spring核心配置文件：在类路径下(resources)创建<code>applicationContext.xml</code>配置文件。</li></ul><img src="https://pic.imgdb.cn/item/60b07e6b08f74bc159b61dc1.jpg" style="zoom:67%;" /><ul><li>在Spring配置文件中配置UserDaoImpl。</li></ul><img src="https://pic.imgdb.cn/item/60b07ea508f74bc159b9af04.jpg" style="zoom:67%;" /><ul><li>使用Spring的API获得Bean示例。</li></ul><img src="https://pic.imgdb.cn/item/60b07ed808f74bc159bcb4e8.jpg" style="zoom:67%;" /><h2 id="三、Spring配置文件"><a href="#三、Spring配置文件" class="headerlink" title="三、Spring配置文件"></a>三、Spring配置文件</h2><h3 id="3-1-Bean标签基本配置"><a href="#3-1-Bean标签基本配置" class="headerlink" title="3.1 Bean标签基本配置"></a>3.1 Bean标签基本配置</h3><ul><li><p>用于配置对象交由<strong>Spring</strong>来创建。</p></li><li><p>默认情况下它调用的是类中的<strong>无参构造函数</strong>，如果没有无参构造函数则不能创建成功。</p></li><li><p>基本属性：</p><ul><li><strong>id</strong>：Bean实例在Spring容器中的唯一标识。</li><li><strong>class</strong>：Bean的全限定名称。</li></ul></li></ul><h3 id="3-2-Bean标签范围配置"><a href="#3-2-Bean标签范围配置" class="headerlink" title="3.2 Bean标签范围配置"></a>3.2 Bean标签范围配置</h3><ul><li>scope：指对象的作用范围，取值如下。</li></ul><img src="https://pic.imgdb.cn/item/60b07f6e08f74bc159c583de.jpg" style="zoom:67%;" /><ul><li><p>当scope的取值为<strong>singleton</strong>时：</p><ul><li>Bean的实例化个数：1个。</li><li>Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例。</li><li>Bean的生命周期：<ul><li>对象创建：当应用加载，创建容器时，对象就被创建了。</li><li>对象运行：只要容器在，对象一直活着。</li><li>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</li></ul></li></ul></li><li><p>当scope的取值为<strong>prototype</strong>时：</p><ul><li>Bean的实例化个数：多个。</li><li>Bean的实例化时机：当调用getBean()方法时实例化Bean。<ul><li>对象创建：当使用对象时，创建新的对象实例。</li><li>对象运行：只要对象在使用中，就一直活着。</li><li>对象销毁：当对象长时间不用时，被Java的垃圾回收器回收了。</li></ul></li></ul></li></ul><h3 id="3-3-Bean生命周期配置"><a href="#3-3-Bean生命周期配置" class="headerlink" title="3.3 Bean生命周期配置"></a>3.3 Bean生命周期配置</h3><ul><li><p><strong>init-method</strong>：指定类中的初始化方法名称。</p></li><li><p><strong>destroy-method</strong>：指定类中销毁方法名称。</p></li></ul><h3 id="3-4-Bean实例化三种方式"><a href="#3-4-Bean实例化三种方式" class="headerlink" title="3.4 Bean实例化三种方式"></a>3.4 Bean实例化三种方式</h3><ul><li><p>无参<strong>构造</strong>方法实例化。</p></li><li><p>工厂<strong>静态</strong>方法实例化。</p></li><li><p>工厂<strong>实例</strong>方法实例化 。</p></li><li><p>使用无参构造方法实例化，它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败。</p></li></ul><img src="https://pic.imgdb.cn/item/60b080ab08f74bc159d9169a.jpg" style="zoom:67%;" /><ul><li>工厂静态方法实例化：工厂的静态方法返回Bean实例。</li></ul><img src="https://pic.imgdb.cn/item/60b0810308f74bc159dddc22.jpg" style="zoom:67%;" /><ul><li>工厂实例方法实例化：工厂的非静态方法返回Bean实例。</li></ul><img src="https://pic.imgdb.cn/item/60b0817e08f74bc159e4d819.jpg" style="zoom:67%;" /><h3 id="3-5-Bean的依赖注入入门"><a href="#3-5-Bean的依赖注入入门" class="headerlink" title="3.5 Bean的依赖注入入门"></a>3.5 Bean的依赖注入入门</h3><ul><li>创建UserServiceImpl，UserServiceImpl内部在调用UserDao的save()方法。</li></ul><img src="https://pic.imgdb.cn/item/60b081fb08f74bc159ebe74c.jpg" style="zoom:67%;" /><ul><li>将UserServiceImpl的创建权交给Spring。</li></ul><img src="https://pic.imgdb.cn/item/60b0824308f74bc159f00a18.jpg" style="zoom:67%;" /><ul><li>从Spring容器中获得UserService进行操作。</li></ul><img src="https://pic.imgdb.cn/item/60b082ba08f74bc159f6f609.jpg" style="zoom:67%;" /><h3 id="3-6-Bean的依赖注入分析"><a href="#3-6-Bean的依赖注入分析" class="headerlink" title="3.6 Bean的依赖注入分析"></a>3.6 Bean的依赖注入分析</h3><ul><li>目前UserService实例和UserDao实例都存在与Spring容器中，当前的做法是在容器外部获得UserService实例和UserDao实例，然后在程序中进行结合。</li></ul><img src="https://pic.imgdb.cn/item/60b0837808f74bc15901eddf.jpg" style="zoom:67%;" /><ul><li>因为UserService和UserDao都在Spring容器中，而最终程序直接使用的是UserService，所以可以在Spring容器中，将UserDao设置到UserService内部。</li></ul><img src="https://pic.imgdb.cn/item/60b083c908f74bc159063167.jpg" style="zoom:67%;" /><h3 id="3-7-Bean的依赖注入概念"><a href="#3-7-Bean的依赖注入概念" class="headerlink" title="3.7 Bean的依赖注入概念"></a>3.7 Bean的依赖注入概念</h3><ul><li><p>依赖注入：它是Spring框架核心IOC的具体实现。</p></li><li><p>在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p></li><li><p>那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。</p></li><li><p>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p></li><li><p>Bean的注入依赖方式：</p><ul><li>构造方法。</li><li>set方法。</li></ul></li><li><p>set方法：配置Spring容器调用set方法进行注入。</p></li></ul><img src="https://pic.imgdb.cn/item/60b0849908f74bc159108563.jpg" style="zoom:67%;" /><ul><li>P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下：首先，需要引入P命名空间，其次，需要修改注入方式。</li></ul><p><img src="https://pic.imgdb.cn/item/60b084df08f74bc15913f74e.jpg"></p><ul><li><p>构造方法注入：创建有参构造。</p></li><li><p>配置Spring容器调用有参构造时进行注入。</p></li></ul><img src="https://pic.imgdb.cn/item/60b0852b08f74bc15917bab8.jpg" style="zoom:67%;" /><h3 id="3-8-Bean的依赖注入的数据类型"><a href="#3-8-Bean的依赖注入的数据类型" class="headerlink" title="3.8 Bean的依赖注入的数据类型"></a>3.8 Bean的依赖注入的数据类型</h3><ul><li><p>上面的操作，都是注入的引用Bean，除了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p></li><li><p>注入数据的三种数据类型：</p><ul><li><strong>普通数据类型</strong>。</li><li><strong>引用数据类型</strong>。</li><li><strong>集合数据类型</strong>。</li></ul></li><li><p>下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。</p></li><li><p>普通数据类型的注入。</p></li></ul><img src="https://pic.imgdb.cn/item/60b085ca08f74bc1591ffdf9.jpg" style="zoom:67%;" /><ul><li>集合数据类型(<code>List&lt;String&gt;</code>)的注入。</li></ul><img src="https://pic.imgdb.cn/item/60b0860708f74bc15922f3da.jpg" style="zoom:67%;" /><img src="https://pic.imgdb.cn/item/60b0862408f74bc159247bc9.jpg" style="zoom:67%;" /><ul><li>集合数据类型(<code>List&lt;User&gt;</code>)的注入。</li></ul><img src="https://pic.imgdb.cn/item/60b0865c08f74bc15927570e.jpg" style="zoom:67%;" /><img src="https://pic.imgdb.cn/item/60b0869108f74bc1592a08e4.jpg" style="zoom:67%;" /><ul><li>集合数据类型(<strong>Properties</strong>)的注入。</li></ul><img src="https://pic.imgdb.cn/item/60b0871808f74bc15930ce3d.jpg" style="zoom:67%;" /><img src="https://pic.imgdb.cn/item/60b0874408f74bc15932fd97.jpg" style="zoom:67%;" /><h3 id="3-9-引入其他配置文件-分模块开发"><a href="#3-9-引入其他配置文件-分模块开发" class="headerlink" title="3.9 引入其他配置文件(分模块开发)"></a>3.9 引入其他配置文件(分模块开发)</h3><ul><li>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载。</li></ul><img src="https://pic.imgdb.cn/item/60b0878208f74bc15936072b.jpg" style="zoom:67%;" /><img src="https://pic.imgdb.cn/item/60b087c808f74bc15939b12b.jpg" style="zoom:67%;" /><h2 id="四、Spring相关API"><a href="#四、Spring相关API" class="headerlink" title="四、Spring相关API"></a>四、Spring相关API</h2><h3 id="4-1-ApplicationContext的继承关系"><a href="#4-1-ApplicationContext的继承关系" class="headerlink" title="4.1 ApplicationContext的继承关系"></a>4.1 ApplicationContext的继承关系</h3><ul><li>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring容器中的Bean对象。</li></ul><img src="https://pic.imgdb.cn/item/60b0882b08f74bc1593e93f5.jpg" style="zoom:80%;" /><h3 id="4-2-ApplicationContext的实现类"><a href="#4-2-ApplicationContext的实现类" class="headerlink" title="4.2 ApplicationContext的实现类"></a>4.2 ApplicationContext的实现类</h3><img src="https://pic.imgdb.cn/item/60b0886808f74bc15941aa14.jpg" style="zoom:80%;" /><h3 id="4-3-getBean-方法的使用"><a href="#4-3-getBean-方法的使用" class="headerlink" title="4.3 getBean()方法的使用"></a>4.3 getBean()方法的使用</h3><img src="https://pic.imgdb.cn/item/60b0889908f74bc15944217d.jpg" style="zoom:67%;" /><ul><li>其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错。</li></ul>]]></content>
    
    
    <summary type="html">SSM——Spring(1)</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Spring5" scheme="http://example.com/tags/Spring5/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2——(1)基础入门</title>
    <link href="http://example.com/2021/05/28/SpringBoot2%E2%80%94%E2%80%94-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2021/05/28/SpringBoot2%E2%80%94%E2%80%94-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2021-05-28T01:24:43.000Z</published>
    <updated>2021-05-28T04:43:36.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot2——-1-基础入门"><a href="#SpringBoot2——-1-基础入门" class="headerlink" title="SpringBoot2——(1)基础入门"></a>SpringBoot2——(1)基础入门</h1><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="1-1-Spring5重大升级"><a href="#1-1-Spring5重大升级" class="headerlink" title="1.1 Spring5重大升级"></a>1.1 Spring5重大升级</h3><ul><li>响应式编程。</li><li>内部源码设计：基于Java8的一些新特性，如：接口默认实现。重新设计源码架构。</li></ul><h3 id="1-2-SpringBoot的优点"><a href="#1-2-SpringBoot的优点" class="headerlink" title="1.2 SpringBoot的优点"></a>1.2 SpringBoot的优点</h3><ul><li><code>Create stand-alone Spring applications</code>：创建独立Spring应用。</li><li><code>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</code>：内嵌web服务器。</li><li><code>Provide opinionated &#39;starter&#39; dependencies to simplify your build configuration</code>：自动starter依赖，简化构建配置。</li><li><code>Automatically configure Spring and 3rd party libraries whenever possible</code>：自动配置Spring以及第三方功能。</li><li><code>Provide production-ready features such as metrics, health checks, and externalized configuration</code>：提供生产级别的监控、健康检查及外部化配置。</li><li><code>Absolutely no code generation and no requirement for XML configuration</code>：无代码生成、无需编写XML。</li></ul><h2 id="二、SpringBoot2入门"><a href="#二、SpringBoot2入门" class="headerlink" title="二、SpringBoot2入门"></a>二、SpringBoot2入门</h2><ul><li>引入依赖。</li></ul><img src="https://pic.imgdb.cn/item/60b0496708f74bc1595aeac8.jpg" style="zoom:67%;" /><ul><li>创建主程序。</li></ul><img src="https://pic.imgdb.cn/item/60b0499408f74bc1595cc8be.jpg" style="zoom:67%;" /><ul><li>编写业务。</li></ul><img src="https://pic.imgdb.cn/item/60b049ef08f74bc159608df6.jpg" style="zoom:67%;" /><ul><li>简化配置：<code>application.properties</code>。</li></ul><img src="https://pic.imgdb.cn/item/60b04a3008f74bc1596346e0.jpg" style="zoom:50%;" /><ul><li>简化部署。</li></ul><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210528094201406.png" style="zoom:67%;" /><ul><li>把项目打成jar包，直接在目标服务器执行即可(取消掉cmd的快速编辑模式)。</li></ul><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2>]]></content>
    
    
    <summary type="html">SpringBoot2——(1)基础入门</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot2" scheme="http://example.com/tags/SpringBoot2/"/>
    
  </entry>
  
  <entry>
    <title>SSM——MyBatis(3)</title>
    <link href="http://example.com/2021/05/28/SSM%E2%80%94%E2%80%94MyBatis-3/"/>
    <id>http://example.com/2021/05/28/SSM%E2%80%94%E2%80%94MyBatis-3/</id>
    <published>2021-05-27T16:50:14.000Z</published>
    <updated>2021-05-27T16:51:41.725Z</updated>
    
    
    <summary type="html">SSM——MyBatis(3)</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SSM——MyBatis(2)</title>
    <link href="http://example.com/2021/05/28/SSM%E2%80%94%E2%80%94MyBatis-2/"/>
    <id>http://example.com/2021/05/28/SSM%E2%80%94%E2%80%94MyBatis-2/</id>
    <published>2021-05-27T16:50:09.000Z</published>
    <updated>2021-05-27T16:52:03.941Z</updated>
    
    
    <summary type="html">SSM——MyBatis(2)</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SSM——MyBatis(1)</title>
    <link href="http://example.com/2021/05/27/SSM%E2%80%94%E2%80%94MyBatis-1/"/>
    <id>http://example.com/2021/05/27/SSM%E2%80%94%E2%80%94MyBatis-1/</id>
    <published>2021-05-27T15:46:17.000Z</published>
    <updated>2021-07-12T15:39:45.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSM——MyBatis-1"><a href="#SSM——MyBatis-1" class="headerlink" title="SSM——MyBatis(1)"></a>SSM——MyBatis(1)</h1><h2 id="一、MyBatis入门操作"><a href="#一、MyBatis入门操作" class="headerlink" title="一、MyBatis入门操作"></a>一、MyBatis入门操作</h2><h3 id="1-1-原始JDBC操作-查询数据"><a href="#1-1-原始JDBC操作-查询数据" class="headerlink" title="1.1 原始JDBC操作(查询数据)"></a>1.1 原始JDBC操作(查询数据)</h3><img src="https://pic.imgdb.cn/item/60afbfa008f74bc159fd6ea4.jpg" style="zoom: 80%;" /><h3 id="1-2-原始JDBC操作-插入数据"><a href="#1-2-原始JDBC操作-插入数据" class="headerlink" title="1.2 原始JDBC操作(插入数据)"></a>1.2 原始JDBC操作(插入数据)</h3><img src="https://pic.imgdb.cn/item/60afbff808f74bc159042f55.jpg" style="zoom:80%;" /><h3 id="1-3-原始JDBC操作的分析"><a href="#1-3-原始JDBC操作的分析" class="headerlink" title="1.3 原始JDBC操作的分析"></a>1.3 原始JDBC操作的分析</h3><ul><li><p>原始jdbc开发存在的问题如下：</p><ul><li><p>数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能。</p></li><li><p>sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p></li><li><p>查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置。</p></li></ul></li><li><p>应对上述问题给出的解决方案：</p><ul><li><p>使用数据库连接池初始化连接资源。</p></li><li><p>将sql语句抽取到xml配置文件中。</p></li><li><p>使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射。</p></li></ul></li></ul><h3 id="1-4-MyBatis简介"><a href="#1-4-MyBatis简介" class="headerlink" title="1.4 MyBatis简介"></a>1.4 MyBatis简介</h3><ul><li><p>mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p></li><li><p>mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</p></li><li><p>最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。</p></li></ul><h2 id="二、MyBatis的快速入门"><a href="#二、MyBatis的快速入门" class="headerlink" title="二、MyBatis的快速入门"></a>二、MyBatis的快速入门</h2><h3 id="2-1-MyBatis的开发步骤"><a href="#2-1-MyBatis的开发步骤" class="headerlink" title="2.1 MyBatis的开发步骤"></a>2.1 MyBatis的开发步骤</h3><ul><li><p>MyBatis开发步骤：</p><ul><li><p>添加MyBatis的坐标。</p></li><li><p>创建user数据表。</p></li><li><p>编写User实体类。</p></li><li><p>编写映射文件<code>UserMapper.xml</code>。</p></li><li><p>编写核心文件<code>SqlMapConfig.xml</code>。</p></li><li><p>编写测试类。</p></li></ul></li></ul><h3 id="2-2-步骤实现"><a href="#2-2-步骤实现" class="headerlink" title="2.2 步骤实现"></a>2.2 步骤实现</h3><ul><li>导入MyBatis的坐标和其他相关坐标。</li></ul><img src="https://pic.imgdb.cn/item/60afc22108f74bc1592c6c62.jpg" style="zoom: 67%;" /><ul><li>创建User数据表。</li></ul><p><img src="https://pic.imgdb.cn/item/60afc27208f74bc159316a6e.jpg"></p><ul><li>编写User实体。</li></ul><img src="https://pic.imgdb.cn/item/60afc2ba08f74bc15936c515.jpg" style="zoom:67%;" /><ul><li>编写UserMapper映射文件。</li></ul><img src="https://pic.imgdb.cn/item/60afc2f708f74bc1593b4644.jpg" style="zoom:67%;" /><ul><li>编写MyBatis核心文件。</li></ul><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210528000517490.png" style="zoom: 67%;" /><ul><li>编写测试代码。</li></ul><img src="https://pic.imgdb.cn/item/60afc39408f74bc15947730a.jpg" style="zoom:67%;" /><h2 id="三、MyBatis的映射文件概述"><a href="#三、MyBatis的映射文件概述" class="headerlink" title="三、MyBatis的映射文件概述"></a>三、MyBatis的映射文件概述</h2><img src="https://pic.imgdb.cn/item/60afc41408f74bc15950a4a6.jpg" style="zoom:67%;" /><h2 id="四、MyBatis的增删改查操作"><a href="#四、MyBatis的增删改查操作" class="headerlink" title="四、MyBatis的增删改查操作"></a>四、MyBatis的增删改查操作</h2><h3 id="4-1-MyBatis的插入数据操作"><a href="#4-1-MyBatis的插入数据操作" class="headerlink" title="4.1 MyBatis的插入数据操作"></a>4.1 MyBatis的插入数据操作</h3><ul><li>编写UserMapper映射文件。</li></ul><img src="https://pic.imgdb.cn/item/60afc48708f74bc15958b978.jpg" style="zoom:67%;" /><ul><li>编写插入实体User的代码。</li></ul><img src="https://pic.imgdb.cn/item/60afc4b308f74bc1595b8cf8.jpg" style="zoom:67%;" /><ul><li>插入操作注意问题：<ul><li>插入语句使用insert标签。</li><li>在映射文件中使用parameterType属性指定要插入的数据类型。</li><li>Sql语句中使用<code>#&#123;实体属性名&#125;</code>方式引用实体中的属性值。</li><li>插入操作使用的API是<code>sqlSession.insert(“命名空间.id”,实体对象)</code>。</li><li>插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即<code>sqlSession.commit()</code>。</li></ul></li></ul><h3 id="4-2-MyBatis的修改数据操作"><a href="#4-2-MyBatis的修改数据操作" class="headerlink" title="4.2 MyBatis的修改数据操作"></a>4.2 MyBatis的修改数据操作</h3><ul><li>编写UserMapper映射文件。</li></ul><img src="https://pic.imgdb.cn/item/60afc57108f74bc159682a7d.jpg" style="zoom:67%;" /><ul><li>编写修改实体User的代码。</li></ul><img src="https://pic.imgdb.cn/item/60afc5de08f74bc1596f1697.jpg" style="zoom:67%;" /><ul><li>修改操作注意问题：<ul><li>修改语句使用update标签。</li><li>修改操作使用的API是<code>sqlSession.update(“命名空间.id”,实体对象)</code>。</li></ul></li></ul><h3 id="4-3-MyBatis的删除数据操作"><a href="#4-3-MyBatis的删除数据操作" class="headerlink" title="4.3 MyBatis的删除数据操作"></a>4.3 MyBatis的删除数据操作</h3><ul><li>编写UserMapper映射文件。</li></ul><img src="https://pic.imgdb.cn/item/60afc66408f74bc159776083.jpg" style="zoom:67%;" /><ul><li>编写删除实体User的代码。</li></ul><img src="https://pic.imgdb.cn/item/60afc71e08f74bc159836458.jpg" style="zoom:67%;" /><ul><li>删除操作注意问题：<ul><li>删除语句使用delete标签。</li><li>Sql语句中使用<code>#&#123;任意字符串&#125;</code>方式引用传递的单个参数。</li><li>删除操作使用的API是<code>sqlSession.delete(“命名空间.id”,Object)</code>。</li></ul></li></ul><h2 id="五、MyBatis的核心配置文件概述"><a href="#五、MyBatis的核心配置文件概述" class="headerlink" title="五、MyBatis的核心配置文件概述"></a>五、MyBatis的核心配置文件概述</h2><h3 id="5-1-MyBatis核心配置文件层级关系"><a href="#5-1-MyBatis核心配置文件层级关系" class="headerlink" title="5.1 MyBatis核心配置文件层级关系"></a>5.1 MyBatis核心配置文件层级关系</h3><p><img src="https://pic.imgdb.cn/item/60afc7c408f74bc1598de52e.jpg"></p><h3 id="5-2-MyBatis常用配置解析"><a href="#5-2-MyBatis常用配置解析" class="headerlink" title="5.2 MyBatis常用配置解析"></a>5.2 MyBatis常用配置解析</h3><h4 id="5-2-1-environments标签"><a href="#5-2-1-environments标签" class="headerlink" title="5.2.1 environments标签"></a>5.2.1 environments标签</h4><ul><li>数据库环境的配置，支持多环境配置。</li></ul><img src="https://pic.imgdb.cn/item/60afc84a08f74bc15995ed85.jpg" style="zoom:67%;" /><ul><li><p>其中，事务管理器(transactionManager)类型有两种：</p><ul><li>JDBC：这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</li><li>MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期(比如JEE应用服务器的上下文)。默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。</li></ul></li><li><p>其中，数据源(dataSource)类型有三种：</p><ul><li>UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。</li><li>POOLED：这种数据源的实现利用“池”的概念将JDBC连接对象组织起来。</li><li>JNDI：这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI上下文的引用。</li></ul></li></ul><h4 id="5-2-2-mapper标签"><a href="#5-2-2-mapper标签" class="headerlink" title="5.2.2 mapper标签"></a>5.2.2 mapper标签</h4><ul><li>该标签的作用是加载映射的，加载方式有如下几种：<ul><li>使用相对于类路径的资源引用，例如：<code>&lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;</code>。</li><li>使用完全限定资源定位符(URL)，例如：<code>&lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;</code>。</li><li>使用映射器接口实现类的完全限定类名，例如：<code>&lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;</code>。</li><li>将包内的映射器接口实现全部注册为映射器，例如：<code>&lt;package name=&quot;org.mybatis.builder&quot;/&gt;</code>。</li></ul></li></ul><h4 id="5-2-3-Properties标签"><a href="#5-2-3-Properties标签" class="headerlink" title="5.2.3 Properties标签"></a>5.2.3 Properties标签</h4><ul><li>实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件。</li></ul><p><img src="https://pic.imgdb.cn/item/60afca1008f74bc159b12242.jpg"></p><h4 id="5-2-4-typeAliases标签"><a href="#5-2-4-typeAliases标签" class="headerlink" title="5.2.4 typeAliases标签"></a>5.2.4 typeAliases标签</h4><ul><li>类型别名是为Java类型设置一个短的名字。原来的类型名称配置如下。</li></ul><img src="https://pic.imgdb.cn/item/60afca6208f74bc159b5dba9.jpg" style="zoom:67%;" /><ul><li>配置typeAliases，为<code>com.itheima.domain.User</code>定义别名为user。</li></ul><img src="https://pic.imgdb.cn/item/60afca9008f74bc159b87e8d.jpg" style="zoom:67%;" /><ul><li>则可以修改如下。</li></ul><img src="https://pic.imgdb.cn/item/60afcad308f74bc159bc8dd4.jpg" style="zoom:67%;" /><ul><li>上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名。</li></ul><img src="https://pic.imgdb.cn/item/60afcb0d08f74bc159bfe664.jpg" style="zoom: 50%;" /><h4 id="5-2-5-mappers标签"><a href="#5-2-5-mappers标签" class="headerlink" title="5.2.5 mappers标签"></a>5.2.5 mappers标签</h4><ul><li>加载映射配置。</li></ul><h2 id="六、MyBatis的相应API"><a href="#六、MyBatis的相应API" class="headerlink" title="六、MyBatis的相应API"></a>六、MyBatis的相应API</h2><h3 id="6-1-SqlSession工厂构建器SqlSessionFactoryBuilder"><a href="#6-1-SqlSession工厂构建器SqlSessionFactoryBuilder" class="headerlink" title="6.1 SqlSession工厂构建器SqlSessionFactoryBuilder"></a>6.1 SqlSession工厂构建器SqlSessionFactoryBuilder</h3><ul><li>常用API：<code>SqlSessionFactory  build(InputStream inputStream)</code>，通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象。</li></ul><img src="https://pic.imgdb.cn/item/60afcc2408f74bc159d0a5a3.jpg" style="zoom:67%;" /><ul><li>其中，Resources工具类，这个类在<code>org.apache.ibatis.io</code>包中。Resources类帮助你从类路径下、文件系统或一个web URL中加载资源文件。</li></ul><h3 id="6-2-SqlSession工厂对象SqlSessionFactory"><a href="#6-2-SqlSession工厂对象SqlSessionFactory" class="headerlink" title="6.2 SqlSession工厂对象SqlSessionFactory"></a>6.2 SqlSession工厂对象SqlSessionFactory</h3><ul><li>SqlSessionFactory有多个个方法创建SqlSession实例。常用的有如下两个。</li></ul><img src="https://pic.imgdb.cn/item/60afcc7d08f74bc159d62a81.jpg" style="zoom: 50%;" /><h3 id="6-3-SqlSession会话对象"><a href="#6-3-SqlSession会话对象" class="headerlink" title="6.3 SqlSession会话对象"></a>6.3 SqlSession会话对象</h3><ul><li>SqlSession实例在MyBatis中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。</li><li>执行语句的方法主要如下。</li></ul><img src="https://pic.imgdb.cn/item/60afccd808f74bc159db3e0a.jpg" style="zoom:67%;" /><ul><li>操作事务的方法主要如下。</li></ul><img src="https://pic.imgdb.cn/item/60afccf008f74bc159dc9532.jpg" style="zoom: 67%;" />]]></content>
    
    
    <summary type="html">SSM——MyBatis(1)</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb——JSON</title>
    <link href="http://example.com/2021/05/26/JavaWeb%E2%80%94%E2%80%94JSON/"/>
    <id>http://example.com/2021/05/26/JavaWeb%E2%80%94%E2%80%94JSON/</id>
    <published>2021-05-26T00:12:27.000Z</published>
    <updated>2021-05-26T00:32:57.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、JSON"><a href="#一、JSON" class="headerlink" title="一、JSON"></a>一、JSON</h1><h2 id="1-什么是JSON"><a href="#1-什么是JSON" class="headerlink" title="1. 什么是JSON"></a>1. 什么是JSON</h2><ul><li>JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON采用完全独立于语言的文本格式，而且很多语言都提供了对json的支持（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这样就使得JSON成为理想的数据交换格式。</li><li>JSON是一种轻量级的数据交换格式。轻量级指的是跟xml做比较。</li><li>数据交换指的是客户端和服务器之间业务数据的传递格式。</li></ul><h2 id="2-JSON在JavaScript中的使用"><a href="#2-JSON在JavaScript中的使用" class="headerlink" title="2. JSON在JavaScript中的使用"></a>2. JSON在JavaScript中的使用</h2><h3 id="2-1-json的定义"><a href="#2-1-json的定义" class="headerlink" title="2.1 json的定义"></a>2.1 json的定义</h3><ul><li>json是由键值对组成，并且由花括号(大括号)包围。每个键由引号引起来，键和值之间使用冒号进行分隔，多组键值对之间进行逗号进行分隔。</li></ul><img src="https://pic.imgdb.cn/item/60ad94a408f74bc1599e8039.jpg" style="zoom:67%;" /><h3 id="2-2-json的访问"><a href="#2-2-json的访问" class="headerlink" title="2.2 json的访问"></a>2.2 json的访问</h3><ul><li>json本身是一个对象。json中的key我们可以理解为是对象中的一个属性。json中的key访问就跟访问对象的属性一样。</li></ul><img src="https://pic.imgdb.cn/item/60ad950808f74bc159a21e73.jpg" style="zoom:67%;" /><h3 id="2-3-json的两个常用方法"><a href="#2-3-json的两个常用方法" class="headerlink" title="2.3 json的两个常用方法"></a>2.3 json的两个常用方法</h3><ul><li>json的存在有两种形式：<ul><li>对象的形式存在，我们叫它json对象。</li><li>字符串的形式存在，我们叫它json字符串。</li></ul></li><li>一般我们要操作json中的数据的时候，需要json对象的格式。</li><li>一般我们要在客户端和服务器之间进行数据交换的时候，使用json字符串。</li><li><code>JSON.stringify()</code>把json对象转换成为json字符串。</li><li><code>JSON.parse()</code>把json字符串转换成为json对象。</li></ul><img src="https://pic.imgdb.cn/item/60ad959e08f74bc159a73057.jpg" style="zoom:67%;" /><h2 id="3-JSON在java中的使用"><a href="#3-JSON在java中的使用" class="headerlink" title="3. JSON在java中的使用"></a>3. JSON在java中的使用</h2><ul><li>javaBean和json的互转</li></ul><img src="https://pic.imgdb.cn/item/60ad964e08f74bc159ad3044.jpg" style="zoom:67%;" /><ul><li>List和json的互转。</li></ul><img src="https://pic.imgdb.cn/item/60ad968408f74bc159af0876.jpg" style="zoom:80%;" /><ul><li>map和json的互转。</li></ul><img src="https://pic.imgdb.cn/item/60ad96ae08f74bc159b070d9.jpg" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">JavaWeb[尚硅谷] Summary for videos</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JSON" scheme="http://example.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>MySQL必知必会 Summary afer reading</title>
    <link href="http://example.com/2021/05/24/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-Summary-afer-reading/"/>
    <id>http://example.com/2021/05/24/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-Summary-afer-reading/</id>
    <published>2021-05-24T10:10:33.000Z</published>
    <updated>2021-05-24T12:49:56.540Z</updated>
    
    
    <summary type="html">MySQL必知必会 Summary afer reading</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer题目总结[77题]</title>
    <link href="http://example.com/2021/05/24/%E5%89%91%E6%8C%87Offer%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-77%E9%A2%98/"/>
    <id>http://example.com/2021/05/24/%E5%89%91%E6%8C%87Offer%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-77%E9%A2%98/</id>
    <published>2021-05-24T06:01:35.000Z</published>
    <updated>2021-05-28T15:55:16.970Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>problem</th><th>problemName</th><th>isNeedReview</th><th>Summary</th><th>Note</th></tr></thead><tbody><tr><td>1</td><td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">数组中重复的数字</a></td><td>💭</td><td></td><td></td></tr><tr><td>2</td><td><a href="https://www.acwing.com/problem/content/15/">不修改数组找出重复的数字</a></td><td>💭</td><td></td><td></td></tr><tr><td>3</td><td><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">二维数组中的查找</a></td><td>✅</td><td></td><td></td></tr><tr><td>4</td><td><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">替换空格</a></td><td>✅</td><td></td><td></td></tr><tr><td>5</td><td><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">从尾到头打印链表</a></td><td>✅</td><td></td><td></td></tr><tr><td>6</td><td><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof">重建二叉树</a></td><td>💭</td><td></td><td></td></tr><tr><td>7</td><td><a href="https://www.acwing.com/problem/content/31/">二叉树的下一个节点</a></td><td>💭</td><td></td><td></td></tr><tr><td>8</td><td><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">用两个栈实现队列</a></td><td>✅</td><td></td><td></td></tr><tr><td>9</td><td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">斐波那契数列</a></td><td>✅</td><td></td><td></td></tr><tr><td>10</td><td><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">旋转数组的最小数字</a></td><td>💭</td><td></td><td></td></tr><tr><td>11</td><td><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">矩阵中的路径</a></td><td>✅</td><td></td><td></td></tr><tr><td>12</td><td><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">机器人的运动范围</a></td><td>✅</td><td></td><td></td></tr><tr><td>13</td><td><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof">剪绳子</a></td><td>💭</td><td></td><td></td></tr><tr><td>14</td><td><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">二进制中1的个数</a></td><td>✅</td><td></td><td></td></tr><tr><td>15</td><td><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">数值的整数次方</a></td><td>✅</td><td></td><td></td></tr><tr><td>16</td><td><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">删除链表的节点</a></td><td>✅</td><td></td><td></td></tr><tr><td>17</td><td><a href="https://www.acwing.com/problem/content/description/27/">删除链表中重复的节点</a></td><td>💭</td><td></td><td></td></tr><tr><td>18</td><td><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof">正则表达式匹配</a></td><td>✅</td><td></td><td></td></tr><tr><td>19</td><td><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof">表示数值的字符串</a></td><td>✅</td><td></td><td></td></tr><tr><td>20</td><td><a href="https://www.acwing.com/problem/content/30/">调整数组顺序使奇数位于偶数前面</a></td><td>✅</td><td></td><td></td></tr><tr><td>21</td><td><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">链表中倒数第k个节点</a></td><td>✅</td><td></td><td></td></tr><tr><td>22</td><td><a href="https://www.acwing.com/problem/content/86/">链表中环的入口结点</a></td><td>✅</td><td></td><td></td></tr><tr><td>23</td><td><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">反转链表</a></td><td>✅</td><td></td><td></td></tr><tr><td>24</td><td><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">合并两个排序的链表</a></td><td>✅</td><td></td><td></td></tr><tr><td>25</td><td><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof">树的子结构</a></td><td>✅</td><td></td><td></td></tr><tr><td>26</td><td><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof">二叉树的镜像</a></td><td>✅</td><td></td><td></td></tr><tr><td>27</td><td><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof">对称的二叉树</a></td><td>✅</td><td></td><td></td></tr><tr><td>28</td><td><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">顺时针打印矩阵</a></td><td>✅</td><td></td><td></td></tr><tr><td>29</td><td><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof">包含min函数的栈</a></td><td>✅</td><td></td><td></td></tr><tr><td>30</td><td><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof">栈的压入、弹出序列</a></td><td>💭</td><td></td><td></td></tr><tr><td>31</td><td><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof">从上到下打印二叉树</a></td><td>✅</td><td></td><td></td></tr><tr><td>32</td><td><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof">从上到下打印二叉树 II</a></td><td>💭</td><td></td><td></td></tr><tr><td>33</td><td><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof">从上到下打印二叉树 III</a></td><td>✅</td><td></td><td></td></tr><tr><td>34</td><td><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof">二叉搜索树的后序遍历序列</a></td><td>✅</td><td></td><td></td></tr><tr><td>35</td><td><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">二叉树中和为某一值的路径</a></td><td>✅</td><td></td><td></td></tr><tr><td>36</td><td><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof">复杂链表的复制</a></td><td>💭</td><td></td><td></td></tr><tr><td>37</td><td><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof">二叉搜索树与双向链表</a></td><td>💭</td><td></td><td></td></tr><tr><td>38</td><td><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof">序列化二叉树</a></td><td>💭</td><td></td><td></td></tr><tr><td>39</td><td><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">字符串的排列</a></td><td>✅</td><td></td><td></td></tr><tr><td>40</td><td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof">数组中出现次数超过一半的数字</a></td><td>✅</td><td></td><td></td></tr><tr><td>41</td><td><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof">最小的k个数</a></td><td>💭</td><td></td><td></td></tr><tr><td>42</td><td><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof">数据流中的中位数</a></td><td>✅</td><td></td><td></td></tr><tr><td>43</td><td><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof">连续子数组的最大和</a></td><td>✅</td><td></td><td></td></tr><tr><td>44</td><td><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof">1～n 整数中 1 出现的次数</a></td><td>💭</td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Data Structures and Algorithms</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>Maven[尚硅谷] Summary after videos</title>
    <link href="http://example.com/2021/05/24/Maven-%E5%B0%9A%E7%A1%85%E8%B0%B7-Summary-after-videos/"/>
    <id>http://example.com/2021/05/24/Maven-%E5%B0%9A%E7%A1%85%E8%B0%B7-Summary-after-videos/</id>
    <published>2021-05-24T01:03:19.000Z</published>
    <updated>2021-05-24T13:12:48.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven-尚硅谷-Summary-after-videos"><a href="#Maven-尚硅谷-Summary-after-videos" class="headerlink" title="Maven[尚硅谷] Summary after videos"></a>Maven[尚硅谷] Summary after videos</h1><h2 id="一、Maven简介"><a href="#一、Maven简介" class="headerlink" title="一、Maven简介"></a>一、Maven简介</h2><h3 id="1-1-Maven的需求"><a href="#1-1-Maven的需求" class="headerlink" title="1.1 Maven的需求"></a>1.1 Maven的需求</h3><ul><li>目前技术在开发中存在的问题：<ul><li>一个项目就是一个工程：如果项目非常庞大，就不适合继续使用package来划分模块。最好是每一个模块对应一个工程，利于分工协作。<strong>借助于Maven就可以将一个项目拆分成多个工程。</strong></li><li>项目中的jar包必须手动复制、粘贴到<code>WEB-INF/lib</code>目录下：带来的问题是同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外也让工程比较臃肿。<strong>借助Maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程”引用”这个文件接口，并不需要真的把jar包复制过来。</strong></li><li>jar包需要别人替我们准备好，或到官网下载：不同技术的官网提供jar包下载的形式不同。有些技术的官网就是通过Maven或SVN等专门的工具来提供下载的。如果是以不规范的方式下载的jar包，那么其中的内容很可能也是不规范的。<strong>借助于Maven可以以一种规范的方式下载jar包。因为所有知名框架或第三方工具的jar包以及按照统一的规范存放在了Maven的中央仓库中。以规范的方式下载的jar包，内容也是可靠的。</strong></li><li>一个jar包依赖的其他jar包需要自己手动加入到项目中：如果所有jar包之间的依赖关系都需要程序员自己非常清楚的了解，那么就会极大的增加学习成本。<strong>Maven会自动将被依赖的jar包导入进来。</strong></li></ul></li></ul><h3 id="1-2-Maven的概述"><a href="#1-2-Maven的概述" class="headerlink" title="1.2 Maven的概述"></a>1.2 Maven的概述</h3><ul><li><p>Maven是Apache软件基金会组织维护的一款自动化构建工具。主要有两个作用:</p><ul><li>maven工程对jar包的管理过程。</li><li>项目的一键构建。</li></ul></li><li><p>构建：以java原文件、框架配置文件、JSP、HTML、图片等资源为原材料，去生产一个可以运行的项目过程，其中包括：编译、部署、搭建。</p><ul><li>编译：Java源文件-&gt;编译-&gt;Class字节码文件-&gt;交给JVM去执行。</li><li>部署：一个BS项目最终运行的并不是动态Web工程本身，而是这个动态Web工程编译的结果。</li></ul></li><li><p>图解编译结果与动态Web工程的区别如下。</p></li></ul><img src="https://img04.sogoucdn.com/app/a/100520146/E8926971E0E6FF5217ECBC0C29A0E5AD" style="zoom:80%;" /><ul><li><p>开发过程中，所有的路径或配置文件中配置的类路径等都是以编译结果的目录结构为标准的。</p></li><li><p>构建过程的各个环节：</p><ul><li>清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备。</li><li>编译：将Java源程序编程成class字节码文件。</li><li>测试：自动测试，自动调用junit程序。</li><li>报告：测试程序执行的结果。</li><li>打包：动态Web工程打war包，Java工程打jar包。</li><li>安装：Maven特定的概念一将打包得到的文件复制到 “仓库”中的指定位置。</li><li>部署：将动态Web工程生成的war包复制到Servlet容器的指定目录下，使其可以运行。</li></ul></li></ul><h3 id="1-3-安装Maven核心程序"><a href="#1-3-安装Maven核心程序" class="headerlink" title="1.3 安装Maven核心程序"></a>1.3 安装Maven核心程序</h3><ul><li>检查JAVA_HOME环境变量，maven本身就是java写的，所以要求必须安装JDK。</li><li><a href="http://maven.apache.org/download.cgi">下载并解压 maven 安装程序</a>，放在一个非中文无空格路径下。</li><li>配置Maven相关的环境变量。</li><li>证是否安装成功，在cmd中运行<code>mvn -v</code>命令。</li></ul><h3 id="1-4-第一个Maven工程-原生Maven"><a href="#1-4-第一个Maven工程-原生Maven" class="headerlink" title="1.4 第一个Maven工程(原生Maven)"></a>1.4 第一个Maven工程(原生Maven)</h3><ul><li>创建约定的目录结构。</li></ul><img src="https://img04.sogoucdn.com/app/a/100520146/107B4ECEF1535DD649518B312FB08C44" style="zoom:67%;" /><ul><li><p>手动创建时为什么要遵守约定的目录结构？Maven要负责我们这个项目的自动化构建，以编译为例，Maven要想自动进行编译，那么它必须知道Java源文件保存在哪里。而我们自定义的东西要想让框架知道或工具知道，有两种方式：</p><ul><li>通过配置的方式告诉框架。</li><li>按照框架约定的来创建。</li></ul></li><li><p>编写pom.xml。</p></li></ul><img src="https://img02.sogoucdn.com/app/a/100520146/85B41871DDA38292E23D271535B1FA88" style="zoom:67%;" /><ul><li>在<code>src/main/java/com/atguigu/maven</code>目录下新建文件<code>Hello.java</code>。</li></ul><img src="https://img03.sogoucdn.com/app/a/100520146/C57B43F7374A441056B1AB612650AA4C" style="zoom:67%;" /><ul><li>在<code>/src/test/java/com/atguigu/maven</code>目录下新建测试文件<code>HelloTest.java</code>。</li></ul><img src="https://img02.sogoucdn.com/app/a/100520146/CB270A4C6AE36E9642022ECCFE75C1D7" style="zoom:67%;" /><ul><li>在命令行中运行基本命令：<ul><li><code>mvn compile</code>：编译。</li><li><code>mvn clean</code>：清理。</li><li><code>mvn test</code>：测试。</li><li><code>mvn package</code>：打包。</li></ul></li><li>运行Maven命令时一定要进入pom.xml文件所在的目录。</li></ul><h2 id="二、Maven核心概念"><a href="#二、Maven核心概念" class="headerlink" title="二、Maven核心概念"></a>二、Maven核心概念</h2><h3 id="2-1-Maven目录结构"><a href="#2-1-Maven目录结构" class="headerlink" title="2.1 Maven目录结构"></a>2.1 Maven目录结构</h3><img src="https://img04.sogoucdn.com/app/a/100520146/107B4ECEF1535DD649518B312FB08C44" style="zoom:67%;" /><h3 id="2-2-Maven常用命令"><a href="#2-2-Maven常用命令" class="headerlink" title="2.2 Maven常用命令"></a>2.2 Maven常用命令</h3><ul><li><code>mvn clean</code>：将target目录删除，但是已经install到仓库里的包不会删除。</li><li><code>mvn compile</code>：编译主程序。</li><li><code>mvn test-compile</code>：编译测试程序。</li><li><code>mvn test</code>：执行测试。</li><li><code>mvn package</code>：打包。</li><li><code>mvn install</code>：安装。</li><li><code>mvn deploy</code>：部署、生成站点。</li></ul><h3 id="2-3-maven工程对jar包的管理过程"><a href="#2-3-maven工程对jar包的管理过程" class="headerlink" title="2.3 maven工程对jar包的管理过程"></a>2.3 maven工程对jar包的管理过程</h3><ul><li>Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中。</li><li>当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。</li><li>本地仓库的默认位置:<code>C:\USERS\USERNAME\.m2\repository</code>。</li><li>Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网到中央仓库下载。</li><li>如果此时无法连接外网，则构建失败。</li><li>修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件。<ul><li>找到Maven解压目录<code>\confsettings.xml</code>。</li><li>在<code>settings.xml</code>文件中找到<code>localRepository</code>标签。</li><li>将<code>&lt;localRepository&gt; /path/to/local/repo&lt;/localRepository&gt;</code>从注释中取出</li><li>将标签体内容修改为已经准备好的Maven仓库目录。</li></ul></li></ul><h3 id="2-4-POM"><a href="#2-4-POM" class="headerlink" title="2.4 POM"></a>2.4 POM</h3><ul><li><p>POM：Project Object Model，项目对象模型。</p></li><li><p>DOM：Document Object Model，文档对象模型。</p></li><li><p>pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置。重要程度相当于web.xml对于动态Web工程。</p></li></ul><h3 id="2-5-坐标"><a href="#2-5-坐标" class="headerlink" title="2.5 坐标"></a>2.5 坐标</h3><ul><li>Maven的坐标，使用三个向量在仓库中唯一定位一个Maven工程：<ul><li>groupid：公司或组织域名的倒序+项目名，<code>com.baidu.projectname</code>。</li><li>artifactid：模块名。</li><li>version：版本。</li></ul></li><li>Maven工程的坐标与仓库中路径的对应关系。</li></ul><h3 id="2-6-仓库"><a href="#2-6-仓库" class="headerlink" title="2.6 仓库"></a>2.6 仓库</h3><ul><li>仓库的分类：<ul><li>本地仓库：当前电脑上部署的仓库目录，为当前电脑上的Maven工程服务。</li><li>远程仓库：<ul><li>私服：搭建在局域网环境中，为局域网范围内的所有Maven工程服务。</li><li>中央仓库：架设在Internet上，为全世界所有Maven工程服务。</li><li>中央仓库镜像：为了分担中央仓库的流量,提升用户访问速度。</li></ul></li><li>仓库中保存的内容：Maven工程。<ul><li>Maven自身所需的插件。</li><li>第三方框架或工具的jar包。</li><li>自己开发的Maven工程。</li></ul></li></ul></li></ul><h3 id="2-7-依赖"><a href="#2-7-依赖" class="headerlink" title="2.7 依赖"></a>2.7 依赖</h3><ul><li>Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。对于我们自己开发的Maven工程，使用<code>mvn install</code>命令安装后就可以进入仓库。</li></ul><img src="https://img02.sogoucdn.com/app/a/100520146/5231F4910AB6C2B414465DB537778271" style="zoom:67%;" /><ul><li>compile范围依赖：<ul><li>对主程序是否有效：有效。</li><li>对测试程序是否有效：有效。</li><li>是否参与打包：参与。</li><li>是否参与部署：参与。</li><li>典型例子：<code>spring-core</code>。</li></ul></li><li>test范围依赖：<ul><li>对主程序是否有效：无效。</li><li>对测试程序是否有效：有效。</li><li>是否参与打包：不参与。</li><li>是否参与部署：不参与。</li><li>典型例子：<code>junit</code>。</li></ul></li><li>provided范围依赖：<ul><li>对主程序是否有效：有效。</li><li>对测试程序是否有效：有效。</li><li>是否参与打包：不参与。</li><li>是否参与部署：不参与。</li><li>典型例子：<code>servlet-api.jar</code>。</li></ul></li></ul><img src="https://img02.sogoucdn.com/app/a/100520146/0813542C73CE6FBE847C0FCBC037240A" style="zoom:67%;" /><ul><li>依赖的传递性。</li></ul><img src="https://pic.imgdb.cn/item/60aba1f8ce272128a6ac114d.jpg" style="zoom:67%;" /><ul><li><p>好处：可以传递的依赖不必在每个模块工程中都重复声明。注意：非compile范围的依赖不能传递。所以在各个工程模块中，如果有需要就得重复声明依赖。</p></li><li><p>依赖排除的设置方式如下。</p></li></ul><img src="https://pic.imgdb.cn/item/60aba26ece272128a6afb720.jpg" style="zoom:67%;" /><ul><li>依赖的原则：<ul><li>作用：解决模块工程之间的jar包冲突问题。</li><li>情景设定一：验证路径最短者优先原则。</li><li>情景设定二：验证路径相同时先声明者优先。</li></ul></li></ul><img src="https://pic.imgdb.cn/item/60aba29cce272128a6b144b7.jpg" style="zoom:67%;" /><img src="https://pic.imgdb.cn/item/60aba2b5ce272128a6b216fb.jpg" style="zoom:67%;" /><ul><li><p>统一管理依赖的版本：</p><ul><li>这里需要对spring各个jar包的依赖版本进行管理，如需要升级到4.1.1。</li><li>配置方式如下。</li></ul></li><li><p>使用properties标签内使用自定义标签统一声明版本号。</p></li></ul><img src="https://pic.imgdb.cn/item/60aba304ce272128a6b4bc24.jpg" style="zoom:67%;" /><ul><li>在需要统一版本的位置，使用<code>$&#123;自定义标签名&#125;</code>引用声明的版本号。</li></ul><img src="https://pic.imgdb.cn/item/60aba36ece272128a6b8baca.jpg" style="zoom:67%;" /><ul><li>其实properties标签配合自定义标签声明数据的配置并不是只能用于声明依赖的版本号。凡是需要统一声明后再引用的场合都可以使用。</li></ul><img src="https://pic.imgdb.cn/item/60aba38cce272128a6ba34b7.jpg" style="zoom:67%;" /><h3 id="2-8-生命周期"><a href="#2-8-生命周期" class="headerlink" title="2.8 生命周期"></a>2.8 生命周期</h3><ul><li>各个构建环节执行的顺序，不能打乱顺序，必须按照既定的正确顺序来执行。</li><li>Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。</li><li>Maven核心程序为了更好的实现自动化构建，按照这一的特点执行生命周期中的各个阶段：不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的位置开始执行。</li></ul><h3 id="2-9-插件与目标"><a href="#2-9-插件与目标" class="headerlink" title="2.9 插件与目标"></a>2.9 插件与目标</h3><ul><li>生命周期的各个阶段仅仅定义了要执行的任务是什么。</li><li>各个阶段和插件的目标是对应的。</li><li>相似的日标由特定的插件来完成。</li><li>可以将目标看作调用插件功能的命令。</li></ul><h3 id="2-10-继承"><a href="#2-10-继承" class="headerlink" title="2.10 继承"></a>2.10 继承</h3><ul><li><p>需求：统一管理各个模块工程中对junit依赖的版本。</p></li><li><p>解决思路：将junit依赖统一提取到“父”工程中，在子工程中声明junit依赖时不指定版本，以父工程中统一设定的为准。同时也便于修改。</p></li><li><p>创建一个Maven工程作为父工程。注意：打包的方式为pom。</p></li></ul><img src="https://pic.imgdb.cn/item/60aba3dece272128a6be27b4.jpg" style="zoom:67%;" /><ul><li>在子工程中声明对父工程的引用。</li></ul><img src="https://pic.imgdb.cn/item/60aba40fce272128a6c07f01.jpg" style="zoom:67%;" /><ul><li>将子工程的坐标中与父工程坐标中重复的内容删除。</li><li>在父工程中统一管理junit的依赖。</li></ul><img src="https://pic.imgdb.cn/item/60aba43ace272128a6c2420b.jpg" style="zoom:67%;" /><ul><li>在子工程中删除junit依赖的版本号部分。</li><li>注意：配置继承后，执行安装命令时要先安装父工程。</li></ul><h3 id="2-11-聚合"><a href="#2-11-聚合" class="headerlink" title="2.11 聚合"></a>2.11 聚合</h3><ul><li>作用：一键安装各个模块工程。</li><li>配置方式：在一个”总的聚合工程“中配置各个参与聚合的模块。</li></ul><img src="https://pic.imgdb.cn/item/60aba472ce272128a6c436a3.jpg" style="zoom:67%;" /><ul><li>使用方式：在聚合工程的<code>pom.xml</code>上点右键-&gt;<code>run as</code>-&gt;<code>maven install</code>(eclipse中)。</li></ul><h2 id="三、博客借鉴"><a href="#三、博客借鉴" class="headerlink" title="三、博客借鉴"></a>三、博客借鉴</h2><ul><li><a href="https://blog.csdn.net/qq_45408390/article/details/116144065">link</a></li></ul>]]></content>
    
    
    <summary type="html">Maven[尚硅谷] Summary after videos</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Maven" scheme="http://example.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Spring5——Spring5新功能</title>
    <link href="http://example.com/2021/05/23/Spring5%E2%80%94%E2%80%94Spring5%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>http://example.com/2021/05/23/Spring5%E2%80%94%E2%80%94Spring5%E6%96%B0%E5%8A%9F%E8%83%BD/</id>
    <published>2021-05-23T06:19:28.000Z</published>
    <updated>2021-05-24T12:48:23.240Z</updated>
    
    
    <summary type="html">Spring5——Spring5新功能</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Spring5新功能" scheme="http://example.com/tags/Spring5%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Spring5——事务操作</title>
    <link href="http://example.com/2021/05/23/Spring5%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/05/23/Spring5%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/</id>
    <published>2021-05-23T02:08:53.000Z</published>
    <updated>2021-05-24T12:47:42.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring5——事务操作"><a href="#Spring5——事务操作" class="headerlink" title="Spring5——事务操作"></a>Spring5——事务操作</h1><h2 id="一、事务概念"><a href="#一、事务概念" class="headerlink" title="一、事务概念"></a>一、事务概念</h2><ul><li>事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。</li><li>**事务四个特性(ACID)**：<ul><li>原子性。</li><li>一致性。</li><li>隔离性。</li><li>持久性。</li></ul></li></ul><h2 id="二、模拟事务操作环境"><a href="#二、模拟事务操作环境" class="headerlink" title="二、模拟事务操作环境"></a>二、模拟事务操作环境</h2><ul><li>创建service，搭建dao，完成对象创建和注入关系。</li></ul><img src="https://pic.imgdb.cn/item/60a9bac735c5199ba7c252ff.jpg" style="zoom:67%;" /><ul><li>在dao创建两个方法：多钱和少钱的方法， 在service创建转账的方法。</li></ul><img src="https://pic.imgdb.cn/item/60a9bc5f35c5199ba7d121e1.jpg" style="zoom:67%;" /><img src="https://pic.imgdb.cn/item/60a9bc9935c5199ba7d32744.jpg" style="zoom:67%;" /><h2 id="三、Spring事务管理概念"><a href="#三、Spring事务管理概念" class="headerlink" title="三、Spring事务管理概念"></a>三、Spring事务管理概念</h2><ul><li>事务添加到JavaEE三层结构里面Service层(业务逻辑层)。</li><li>在Spring进行事务管理操作有两种方式：<ul><li>编程式事务管理。</li><li>声明式事务管理(推荐使用)。</li></ul></li><li>声明式事务管理：<ul><li>基于注解方式(推荐使用)。</li><li>基于xml配置文件方式。</li></ul></li><li>在Spring进行声明式事务管理，底层使用AOP原理。</li><li>Spring事务管理API：提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类。</li></ul><h2 id="四、声明式事务管理——注解方式"><a href="#四、声明式事务管理——注解方式" class="headerlink" title="四、声明式事务管理——注解方式"></a>四、声明式事务管理——注解方式</h2><ul><li>在Spring配置文件配置事务管理器。</li></ul><img src="https://pic.imgdb.cn/item/60a9ef4135c5199ba7921de6.jpg" style="zoom:80%;" /><ul><li>在Spring配置文件，开启事务注解，引入名称空间。</li></ul><img src="https://pic.imgdb.cn/item/60a9efa135c5199ba79649c1.jpg" style="zoom:67%;" /><ul><li>开启事务注解。</li></ul><img src="https://pic.imgdb.cn/item/60a9efea35c5199ba799815b.jpg" style="zoom:67%;" /><h2 id="五、声明式事务管理参数配置"><a href="#五、声明式事务管理参数配置" class="headerlink" title="五、声明式事务管理参数配置"></a>五、声明式事务管理参数配置</h2><ul><li>Transactional事务传播行为：<ul><li>在service类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数。</li><li>propagation(事务传播行为)：多事务方法直接进行调用，这个过程中事务是如何进行管理的。</li><li>spring框架事务传播行为有七种：下面只介绍常用的两种传播行为。</li></ul></li></ul><img src="https://pic.imgdb.cn/item/60a9f07e35c5199ba7a043db.jpg" style="zoom:67%;" /><img src="https://pic.imgdb.cn/item/60a9f0b235c5199ba7a27e30.jpg" style="zoom:67%;" /><ul><li><p>ioslation(事务隔离级别)：</p><ul><li>事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题。</li><li>有三个读问题：脏读、不可重复读、虚读。</li><li>解决：通过设置事务隔离级别，解决读问题。</li><li><code>@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ)</code>。</li></ul></li><li><p>timeout(超时时间)：</p><ul><li>事务需要在一定时间内进行提交，如果不提交进行回滚。</li><li>默认值是-1(不超时)，设置时间以秒单位进行计算。</li></ul></li><li><p>readOnly(是否只读)：</p><ul><li>读：查询操作，写：添加修改删除操作。</li><li>readOnly默认值false，表示可以查询，可以添加修改删除操作。</li><li>设置readOnly值是true，设置成true之后，只能查询。</li></ul></li><li><p>rollbackFor(回滚)：设置出现哪些异常进行事务回滚。</p></li><li><p>noRollbackFor(不回滚)： 设置出现哪些异常不进行事务回滚。</p></li></ul><h2 id="六、声明式事务管理——XML方式"><a href="#六、声明式事务管理——XML方式" class="headerlink" title="六、声明式事务管理——XML方式"></a>六、声明式事务管理——XML方式</h2><p><img src="https://pic.imgdb.cn/item/60a9f2c835c5199ba7b9556b.jpg"></p><h2 id="七、事务操作——完全注解声明式事务管理"><a href="#七、事务操作——完全注解声明式事务管理" class="headerlink" title="七、事务操作——完全注解声明式事务管理"></a>七、事务操作——完全注解声明式事务管理</h2><img src="https://pic.imgdb.cn/item/60a9f3ab35c5199ba7c3ec5d.jpg" style="zoom:80%;" />]]></content>
    
    
    <summary type="html">Spring5——AOP</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="事务操作" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Spring5——JDBCTemplate</title>
    <link href="http://example.com/2021/05/23/Spring5%E2%80%94%E2%80%94JDBCTemplate/"/>
    <id>http://example.com/2021/05/23/Spring5%E2%80%94%E2%80%94JDBCTemplate/</id>
    <published>2021-05-23T01:35:08.000Z</published>
    <updated>2021-05-23T02:07:45.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring5——JDBCTemplate"><a href="#Spring5——JDBCTemplate" class="headerlink" title="Spring5——JDBCTemplate"></a>Spring5——JDBCTemplate</h1><h2 id="一、JDBCTemplate概念"><a href="#一、JDBCTemplate概念" class="headerlink" title="一、JDBCTemplate概念"></a>一、JDBCTemplate概念</h2><ul><li>Spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库操作。</li><li>引入相关jar包。</li><li>在Spring配置文件配置数据库连接池。</li></ul><img src="https://pic.imgdb.cn/item/60a9b4be35c5199ba788fb67.jpg" style="zoom:67%;" /><ul><li>配置JDBCTemplate对象，注入DataSource。</li></ul><img src="https://pic.imgdb.cn/item/60a9b4f935c5199ba78b346c.jpg" style="zoom:67%;" /><ul><li>创建service类，创建dao类，在dao注入JDBCTemplate对象</li></ul><img src="https://pic.imgdb.cn/item/60a9b5b035c5199ba7925843.jpg" style="zoom:67%;" /><h2 id="二、JDBCTemplate操作数据库——添加"><a href="#二、JDBCTemplate操作数据库——添加" class="headerlink" title="二、JDBCTemplate操作数据库——添加"></a>二、JDBCTemplate操作数据库——添加</h2><ul><li>在dao进行数据库添加操作，调用JDBCTemplate对象里面update方法实现添加操作。</li></ul><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210523095952781.png" style="zoom:67%;" /><h2 id="三、JDBCTemplate操作数据库——修改和删除"><a href="#三、JDBCTemplate操作数据库——修改和删除" class="headerlink" title="三、JDBCTemplate操作数据库——修改和删除"></a>三、JDBCTemplate操作数据库——修改和删除</h2><ul><li>使用JDBCTemplate模板所实现的 “增删改”都是调用了同一个update方法。</li></ul><img src="https://pic.imgdb.cn/item/60a9b78935c5199ba7a43b05.jpg" style="zoom:67%;" /><h2 id="四、JDBCTemplate操作数据库——查询返回某个值"><a href="#四、JDBCTemplate操作数据库——查询返回某个值" class="headerlink" title="四、JDBCTemplate操作数据库——查询返回某个值"></a>四、JDBCTemplate操作数据库——查询返回某个值</h2><img src="https://pic.imgdb.cn/item/60a9b7bf35c5199ba7a60ed0.jpg" style="zoom:67%;" /><h2 id="五、JDBCTemplate操作数据库——查询返回对象"><a href="#五、JDBCTemplate操作数据库——查询返回对象" class="headerlink" title="五、JDBCTemplate操作数据库——查询返回对象"></a>五、JDBCTemplate操作数据库——查询返回对象</h2><img src="https://pic.imgdb.cn/item/60a9b80035c5199ba7a8462d.jpg" style="zoom:67%;" /><h2 id="六、JDBCTemplate操作数据库——查询返回集合"><a href="#六、JDBCTemplate操作数据库——查询返回集合" class="headerlink" title="六、JDBCTemplate操作数据库——查询返回集合"></a>六、JDBCTemplate操作数据库——查询返回集合</h2><img src="https://pic.imgdb.cn/item/60a9b82835c5199ba7a9aacd.jpg" style="zoom:67%;" /><h2 id="七、JDBCTemplate操作数据库——批量操作"><a href="#七、JDBCTemplate操作数据库——批量操作" class="headerlink" title="七、JDBCTemplate操作数据库——批量操作"></a>七、JDBCTemplate操作数据库——批量操作</h2><img src="https://pic.imgdb.cn/item/60a9b86935c5199ba7ac0a54.jpg" style="zoom:67%;" /><img src="https://pic.imgdb.cn/item/60a9b8b935c5199ba7af09dc.jpg" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">Spring5——JDBCTemplate</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JDBCTemplate" scheme="http://example.com/tags/JDBCTemplate/"/>
    
  </entry>
  
  <entry>
    <title>Spring5——AOP</title>
    <link href="http://example.com/2021/05/21/Spring5%E2%80%94%E2%80%94AOP/"/>
    <id>http://example.com/2021/05/21/Spring5%E2%80%94%E2%80%94AOP/</id>
    <published>2021-05-21T07:28:47.000Z</published>
    <updated>2021-05-22T13:56:54.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring5——AOP"><a href="#Spring5——AOP" class="headerlink" title="Spring5——AOP"></a>Spring5——AOP</h1><h2 id="一、AOP基本概念"><a href="#一、AOP基本概念" class="headerlink" title="一、AOP基本概念"></a>一、AOP基本概念</h2><ul><li>面向切面编程(方面)，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</li><li>通俗描述：不通过修改源代码方式，在主干功能里面添加新功能。</li></ul><h2 id="二、AOP底层原理"><a href="#二、AOP底层原理" class="headerlink" title="二、AOP底层原理"></a>二、AOP底层原理</h2><ul><li>AOP底层使用动态代理。</li><li>动态代理分为两种情况：<ul><li>情况一：有接口情况，使用JDK动态代理；创建接口实现类代理对象，增强类的方法。</li><li>情况二：没有接口情况，使用CGLIB动态代理；创建子类的代理对象，增强类的方法。</li></ul></li></ul><h2 id="三、AOP——JDK动态代理"><a href="#三、AOP——JDK动态代理" class="headerlink" title="三、AOP——JDK动态代理"></a>三、AOP——JDK动态代理</h2><ul><li><p>使用JDK动态代理，使用Proxy类里面的方法创建代理对象。</p></li><li><p>调用newProxyInstance方法，方法有三个参数：<code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>：</p><ul><li>第一参数：类加载器。</li><li>第二参数：增强方法所在的类，这个类实现的接口，支持多个接口。</li><li>第三参数：实现这个接口InvocationHandler，创建代理对象，写增强的部分。</li></ul></li><li><p>创建接口，定义方法。</p></li></ul><img src="https://pic.imgdb.cn/item/60a8ee1c6ae4f77d357d7469.jpg" style="zoom:67%;" /><ul><li>创建接口实现类，实现方法。</li></ul><img src="https://pic.imgdb.cn/item/60a8ee4d6ae4f77d357ef6c5.jpg" style="zoom:80%;" /><ul><li>使用Proxy类创建接口代理对象。</li></ul><p><img src="https://pic.imgdb.cn/item/60a8eebe6ae4f77d3582598e.jpg"></p><h2 id="四、AOP术语"><a href="#四、AOP术语" class="headerlink" title="四、AOP术语"></a>四、AOP术语</h2><ul><li><p>连接点：类里面哪些方法可以被增强，这些方法称为连接点。</p></li><li><p>切入点：实际被真正增强的方法称为切入点。</p></li><li><p>通知(增强)：实际增强的逻辑部分称为通知，且分为以下五种类型：</p><ul><li>前置通知。</li><li>后置通知。</li><li>环绕通知(在方法的前面和后面都执行)。</li><li>异常通知。</li><li>最终通知。</li></ul></li><li><p>切面：把通知应用到切入点过程。</p></li></ul><h2 id="五、AOP操作"><a href="#五、AOP操作" class="headerlink" title="五、AOP操作"></a>五、AOP操作</h2><ul><li><p>Spring框架一般都是基于AspectJ实现AOP操作，AspectJ不是Spring组成部分，独立AOP框架，一般把AspectJ和Spirng框架一起使用，进行AOP操作。</p></li><li><p>基于AspectJ实现AOP操作：</p><ul><li>基于xml配置文件实现。</li><li>基于注解方式实现(使用)。</li></ul></li><li><p>引入相关AOP依赖的jar包。</p></li><li><p>切入点表达式：要对哪个类里面的哪个方法进行增强(*代表任意的修饰符)。</p></li></ul><p><img src="https://pic.imgdb.cn/item/60a8f0f06ae4f77d3592466e.jpg"></p><h2 id="六、基于AspectJ实现AOP操作-注解方式"><a href="#六、基于AspectJ实现AOP操作-注解方式" class="headerlink" title="六、基于AspectJ实现AOP操作(注解方式)"></a>六、基于AspectJ实现AOP操作(注解方式)</h2><ul><li>创建增强类与被增强类。</li></ul><img src="https://pic.imgdb.cn/item/60a8f16b6ae4f77d3595eb76.jpg" style="zoom:67%;" /><ul><li>进行通知的配置。</li></ul><p><img src="https://pic.imgdb.cn/item/60a8f1a96ae4f77d3597c77b.jpg"></p><ul><li>使用注解创建User和UserProxy对象，并在增强类上面添加注解@Aspect。</li></ul><p><img src="https://pic.imgdb.cn/item/60a8f2096ae4f77d359a962d.jpg"></p><ul><li>配置不同类型的通知：在增强类的里面，在作为通知方法上面添加类型注解，使用切入点表达式进行配置(相同的切入点可以进行抽取来节省代码)。</li></ul><img src="https://pic.imgdb.cn/item/60a9050e6ae4f77d35344d0d.jpg" style="zoom: 80%;" /><ul><li>有多个增强类对同一个方法进行增强，设置增强类优先级。</li></ul><img src="https://pic.imgdb.cn/item/60a9073b6ae4f77d354af08d.jpg" style="zoom:67%;" /><ul><li>完全使用注解开发。</li></ul><img src="https://pic.imgdb.cn/item/60a90d8d6ae4f77d3579d8e1.jpg" style="zoom:50%;" /><h2 id="六、基于AspectJ实现AOP操作-xml配置文件方式"><a href="#六、基于AspectJ实现AOP操作-xml配置文件方式" class="headerlink" title="六、基于AspectJ实现AOP操作(xml配置文件方式)"></a>六、基于AspectJ实现AOP操作(xml配置文件方式)</h2><p><img src="https://pic.imgdb.cn/item/60a90ca36ae4f77d35727e42.jpg"></p>]]></content>
    
    
    <summary type="html">Spring5——AOP</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring5——IOC容器</title>
    <link href="http://example.com/2021/05/21/Spring5%E2%80%94%E2%80%94IOC%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2021/05/21/Spring5%E2%80%94%E2%80%94IOC%E5%AE%B9%E5%99%A8/</id>
    <published>2021-05-21T00:33:26.000Z</published>
    <updated>2021-05-25T03:03:23.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring5——IOC容器"><a href="#Spring5——IOC容器" class="headerlink" title="Spring5——IOC容器"></a>Spring5——IOC容器</h1><h2 id="一、IOC容器基本概念"><a href="#一、IOC容器基本概念" class="headerlink" title="一、IOC容器基本概念"></a>一、IOC容器基本概念</h2><ul><li>什么是IOC(控制反转)？<ul><li>把对象创建和对象之间的调用过程，交给Spring进行管理。</li><li>使用IOC目的：为了降低耦合度。</li></ul></li><li>IOC底层原理：xml解析、工厂模式、反射。</li></ul><h2 id="二、IOC接口"><a href="#二、IOC接口" class="headerlink" title="二、IOC接口"></a>二、IOC接口</h2><ul><li>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂。</li><li>**Spring提供的IOC容器实现的两种方式(两个接口)**：<ul><li>BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用(加载配置文件时候不会创建对象，在获取对象时才会创建对象)。</li><li>ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用(加载配置文件时候就会把在配置文件对象进行创建)。</li></ul></li></ul><img src="https://pic.imgdb.cn/item/60a706a56ae4f77d35d74f10.jpg" style="zoom:80%;" /><ul><li><code>FileSystemXmlApplicationContext</code>：代表从src下的类路径查找。</li><li><code>ClassPathXmlApplicationContext</code>：代表从盘下的具体路径查找。</li><li><code>ConfigurableApplicationContext</code>：代表包含相关的扩展功能。</li></ul><h2 id="三、IOC操作Bean管理-基于XML方式"><a href="#三、IOC操作Bean管理-基于XML方式" class="headerlink" title="三、IOC操作Bean管理(基于XML方式)"></a>三、IOC操作Bean管理(基于XML方式)</h2><h3 id="1-创建对象与注入属性"><a href="#1-创建对象与注入属性" class="headerlink" title="1. 创建对象与注入属性"></a>1. 创建对象与注入属性</h3><ul><li><p><strong>IOC操作Bean管理的两个操作</strong>：</p><ul><li>Spring创建对象。</li><li>Spring注入属性。</li></ul></li><li><p>基于XML配置文件创建对象：</p><ul><li>在spring配置文件中，使用bean标签，就可以在标签中添加对应属性，实现对象的创建。</li><li>id属性：唯一标识。</li><li>class属性：类全路径。</li><li>创建对象时，默认执行无参构造方法完成对象的创建。</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/60a64b7e6ae4f77d351bbf07.jpg"></p><ul><li><p><strong>基于XML方式注入属性</strong>：</p><ul><li>使用set方法注入。</li><li>使用有参构造函数注入。</li></ul></li><li><p>使用set方法注入。</p></li></ul><img src="https://pic.imgdb.cn/item/60ac68f008f74bc15903ad38.png" style="zoom:67%;" /><img src="https://pic.imgdb.cn/item/60a70a966ae4f77d35ee656d.jpg" style="zoom:67%;" /><ul><li>使用有参构造函数注入。</li></ul><img src="https://pic.imgdb.cn/item/60a70ae56ae4f77d35f02243.jpg" style="zoom:67%;" /><img src="https://pic.imgdb.cn/item/60a70b7e6ae4f77d35f3a37c.jpg" style="zoom:67%;" /><ul><li>p名称空间注入(了解即可，可以简化基于xml配置方式)。</li></ul><img src="https://pic.imgdb.cn/item/60a7578f6ae4f77d3501ecfa.jpg" style="zoom: 80%;" /><h3 id="2-注入空值与特殊符号"><a href="#2-注入空值与特殊符号" class="headerlink" title="2. 注入空值与特殊符号"></a>2. 注入空值与特殊符号</h3><ul><li>注入空值。</li></ul><img src="https://pic.imgdb.cn/item/60a7598f6ae4f77d35114a87.jpg" style="zoom:67%;" /><ul><li>注入特殊符号。</li></ul><img src="https://pic.imgdb.cn/item/60a75a256ae4f77d3515ba8b.jpg" style="zoom:67%;" /><h3 id="3-注入属性——外部bean"><a href="#3-注入属性——外部bean" class="headerlink" title="3. 注入属性——外部bean"></a>3. 注入属性——外部bean</h3><ul><li>创建两个类service和dao类，并在service中调用dao里面的方法。</li></ul><img src="https://p6.toutiaoimg.com/origin/pgc-image/b13b9ccd0c6a43c7b6f247f3ca7d76b5" style="zoom:67%;" /><ul><li>在spring配置文件中进行配置。</li></ul><img src="https://pic.imgdb.cn/item/60a75ca06ae4f77d352cd0f5.jpg" style="zoom:67%;" /><h3 id="4-注入属性——内部bean"><a href="#4-注入属性——内部bean" class="headerlink" title="4. 注入属性——内部bean"></a>4. 注入属性——内部bean</h3><ul><li>一对多关系：部门和员工。一个部门有多个员工，一个员工属于一个部门(部门是一，员工是多)。在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</li></ul><img src="https://pic.imgdb.cn/item/60a75d9f6ae4f77d35361694.jpg" style="zoom:67%;" /><ul><li>在spring配置文件中配置。</li></ul><img src="https://pic.imgdb.cn/item/60a75e076ae4f77d3539eef1.jpg" style="zoom:67%;" /><h3 id="5-注入属性——级联赋值"><a href="#5-注入属性——级联赋值" class="headerlink" title="5. 注入属性——级联赋值"></a>5. 注入属性——级联赋值</h3><ul><li>方式一。</li></ul><img src="https://pic.imgdb.cn/item/60a75f836ae4f77d35482b43.jpg" style="zoom:67%;" /><ul><li>方式二：前提必须生成dept的get方法。</li></ul><img src="https://pic.imgdb.cn/item/60a75fe16ae4f77d354bbf6d.jpg" style="zoom:67%;" /><h3 id="6-注入属性——集合属性"><a href="#6-注入属性——集合属性" class="headerlink" title="6. 注入属性——集合属性"></a>6. 注入属性——集合属性</h3><ul><li>创建类，定义数组、list、map、set类型属性，生成对应set方法。</li></ul><img src="https://pic.imgdb.cn/item/60a7616c6ae4f77d355836bf.jpg" style="zoom:67%;" /><ul><li>在spring配置文件进行配置。</li></ul><img src="https://pic.imgdb.cn/item/60a762726ae4f77d355fe4a2.jpg" style="zoom:67%;" /><h3 id="7-在集合里面设置对象类型值"><a href="#7-在集合里面设置对象类型值" class="headerlink" title="7. 在集合里面设置对象类型值"></a>7. 在集合里面设置对象类型值</h3><ul><li>首先创建一个类，其有List集合属性，集合构成元素为Course类对象，并设置此属性的set方法。</li></ul><img src="https://pic.imgdb.cn/item/60a7636b6ae4f77d35673dc5.jpg" style="zoom:67%;" /><h3 id="8-把集合注入部分提取出来"><a href="#8-把集合注入部分提取出来" class="headerlink" title="8. 把集合注入部分提取出来"></a>8. 把集合注入部分提取出来</h3><ul><li>在Spring配置文件中引入名称空间，并用util标签完成List集合注入提取。</li></ul><img src="https://pic.imgdb.cn/item/60a766be6ae4f77d35803e5c.jpg" style="zoom:67%;" /><h2 id="四、IOC操作Bean管理-FactoryBean"><a href="#四、IOC操作Bean管理-FactoryBean" class="headerlink" title="四、IOC操作Bean管理(FactoryBean)"></a>四、IOC操作Bean管理(FactoryBean)</h2><h3 id="1-Bean的类型"><a href="#1-Bean的类型" class="headerlink" title="1. Bean的类型"></a>1. Bean的类型</h3><ul><li><p>Spring有两种类型bean：</p><ul><li>一种普通bean：在配置文件中定义bean类型就是返回类型。</li><li>一种工厂bean(FactoryBean)：在配置文件定义bean类型可以和<strong>返回类型不一样</strong>：<ul><li>第一步：创建类，让这个类作为工厂bean，实现接口FactoryBean。</li><li>第二步：实现接口里面的方法，在实现的方法中定义返回的bean类型。</li></ul></li></ul></li><li><p>类声明如下。</p></li></ul><img src="https://pic.imgdb.cn/item/60a7689d6ae4f77d358dac5a.jpg" style="zoom:67%;" /><ul><li>XML配置如下。</li></ul><img src="https://pic.imgdb.cn/item/60a7691c6ae4f77d3590d056.jpg" style="zoom:67%;" /><ul><li>测试如下。</li></ul><p><img src="https://pic.imgdb.cn/item/60a769746ae4f77d3592eb9e.jpg"></p><h3 id="2-Bean作用域"><a href="#2-Bean作用域" class="headerlink" title="2. Bean作用域"></a>2. Bean作用域</h3><ul><li> 在Spring里面，默认情况下bean是单实例对象，下面进行作用域设置。</li><li>scope属性值：第一个值为默认值singleton，表示是单实例对象；第二个值prototype，表示是多实例对象。</li></ul><p><img src="https://pic.imgdb.cn/item/60a76a466ae4f77d35984a3e.jpg"></p><ul><li>singleton和prototype的区别：<ul><li>singleton单实例，prototype多实例。</li><li>设置scope值是singleton时候，<strong>加载spring配置文件时候就会创建单实例对象</strong> ；设置scope值是prototype时候，不是在加载spring配置文件时候创建对象，在<strong>调用getBean方法时候创建多实例对象</strong>。</li></ul></li></ul><h3 id="3-Bean的生命周期"><a href="#3-Bean的生命周期" class="headerlink" title="3. Bean的生命周期"></a>3. Bean的生命周期</h3><ul><li>生命周期：从对象创建到对象销毁的过程。</li><li>Bean生命周期：<ul><li>通过构造器创建Bean实例(无参数构造)。</li><li>为Bean的属性设置值和对其他Bean引用(调用set方法)。</li><li>调用Bean的初始化的方法(需要进行配置初始化的方法)。</li><li>Bean可以使用了(对象获取到了)。</li><li>当容器关闭时候，调用Bean的销毁的方法(需要进行配置销毁的方法)。</li></ul></li><li>设置类如下。</li></ul><img src="https://pic.imgdb.cn/item/60a76b6a6ae4f77d35a036e4.jpg" style="zoom:67%;" /><ul><li>设置后置处理器实现类。</li></ul><p><img src="https://pic.imgdb.cn/item/60a76bc36ae4f77d35a26934.jpg"></p><ul><li>配置xml文件参数。</li></ul><p><img src="https://pic.imgdb.cn/item/60a76c6b6ae4f77d35a6d052.jpg"></p><ul><li>测试代码。</li></ul><p><img src="https://pic.imgdb.cn/item/60a76f006ae4f77d35b9154e.jpg"></p><ul><li>增加bean的后置处理器后，bean生命周期有七步(正常生命周期为五步，而配置后置处理器后为七步)：<ul><li>通过构造器创建bean实例。</li><li>为bean的属性设置值和对其他bean引用。</li><li>把bean实例传递bean后置处理器的方法postProcessBeforeInitialization</li><li>调用bean的初始化的方法。</li><li>把bean实例传递bean后置处理器的方法postProcessAfterInitialization。</li><li>bean可以使用了。</li><li>当容器关闭时候，调用bean的销毁的方法。</li></ul></li></ul><h3 id="4-引用外部属性文件"><a href="#4-引用外部属性文件" class="headerlink" title="4. 引用外部属性文件"></a>4. 引用外部属性文件</h3><h4 id="4-1-直接配置数据库信息"><a href="#4-1-直接配置数据库信息" class="headerlink" title="4.1 直接配置数据库信息"></a>4.1 直接配置数据库信息</h4><ul><li>配置Druid连接池。</li><li>引入Druid连接池依赖jar包。</li></ul><p><img src="https://pic.imgdb.cn/item/60a76fe96ae4f77d35bfde9c.jpg"></p><h4 id="4-2-引入外部属性文件配置数据库连接池"><a href="#4-2-引入外部属性文件配置数据库连接池" class="headerlink" title="4.2 引入外部属性文件配置数据库连接池"></a>4.2 引入外部属性文件配置数据库连接池</h4><ul><li>创建外部属性文件：properties格式文件，写数据库信息(jdbc.properties)。</li></ul><img src="https://pic.imgdb.cn/item/60a7708a6ae4f77d35c456fe.jpg" style="zoom:67%;" /><ul><li>把外部properties属性文件引入到spring配置文件中——引入context名称空间。</li></ul><p><img src="https://pic.imgdb.cn/item/60a7710d6ae4f77d35c7f52b.jpg"></p><h2 id="五、IOC操作Bean管理-基于注解方式"><a href="#五、IOC操作Bean管理-基于注解方式" class="headerlink" title="五、IOC操作Bean管理(基于注解方式)"></a>五、IOC操作Bean管理(基于注解方式)</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li>注解：<ul><li>注解是代码特殊标记，格式：<code>@注解名称(属性名称=属性值, 属性名称=属性值…)</code>。</li><li>使用注解，注解作用在类上面，方法上面，属性上面。</li><li>使用注解目的：简化xml配置。</li></ul></li><li>Spring针对Bean管理中创建对象提供注解， 下面四个注解功能是一样的，都可以用来创建bean实例：<ul><li><code>@Component</code>：普通的组件。</li><li><code>@Service</code>：常用于业务逻辑(Server层)。</li><li><code>@Controller</code>：常用于web层。</li><li><code>@Repository</code>：常用于持久层(Dao层)。</li></ul></li></ul><h3 id="2-基于注解方式实现对象创建"><a href="#2-基于注解方式实现对象创建" class="headerlink" title="2. 基于注解方式实现对象创建"></a>2. 基于注解方式实现对象创建</h3><ul><li>引入依赖(引入<strong>spring-aop jar包</strong>)。</li><li>开启组件扫描。</li></ul><img src="https://pic.imgdb.cn/item/60a78ae66ae4f77d3569ec96.jpg" style="zoom:67%;" /><ul><li> 创建类，在类上面添加创建对象注解。</li></ul><img src="https://pic.imgdb.cn/item/60a78b4d6ae4f77d356c8581.jpg" style="zoom:67%;" /><ul><li>开启组件扫描细节配置如下。</li></ul><p><img src="https://pic.imgdb.cn/item/60a78bdb6ae4f77d3570019d.jpg"></p><h3 id="3-基于注解方式实现属性注入"><a href="#3-基于注解方式实现属性注入" class="headerlink" title="3. 基于注解方式实现属性注入"></a>3. 基于注解方式实现属性注入</h3><ul><li><code>@Autowired</code>：根据属性类型进行自动装配。<ul><li>第一步：把service和dao对象创建，在service和dao类添加创建对象注解。</li><li>第二步：在service注入dao对象，在service类添加dao类型属性，在属性上面使用注解<code>Autowired</code>。</li></ul></li></ul><img src="https://pic.imgdb.cn/item/60a78c9c6ae4f77d35750314.jpg" style="zoom:67%;" /><ul><li><code>@Qualifier</code>：根据名称进行注入，这个<code>@Qualifier</code>注解的使用，和上面<code>@Autowired</code>一起使用。</li></ul><img src="https://pic.imgdb.cn/item/60a78d246ae4f77d3578ae99.jpg" style="zoom:67%;" /><ul><li><code>@Resource</code>：可以根据类型注入，也可以根据名称注入(它属于javax包下的注解，不推荐使用)。</li></ul><img src="https://pic.imgdb.cn/item/60a78d7b6ae4f77d357af55f.jpg" style="zoom:67%;" /><ul><li><code>@Value</code>：注入普通类型属性。</li></ul><img src="https://pic.imgdb.cn/item/60a78dc16ae4f77d357cc37a.jpg" style="zoom:67%;" /><h2 id="六、完全注解开发"><a href="#六、完全注解开发" class="headerlink" title="六、完全注解开发"></a>六、完全注解开发</h2><ul><li>创建配置类，替代xml配置文件。</li></ul><img src="https://pic.imgdb.cn/item/60a78e086ae4f77d357e904c.jpg" style="zoom:67%;" /><ul><li>编写测试类。</li></ul><img src="https://pic.imgdb.cn/item/60a78e7a6ae4f77d35815664.jpg" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">Spring5——IOC容器</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="IOC容器" scheme="http://example.com/tags/IOC%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb——JSTL标签库</title>
    <link href="http://example.com/2021/05/20/JavaWeb%E2%80%94%E2%80%94JSTL%E6%A0%87%E7%AD%BE%E5%BA%93/"/>
    <id>http://example.com/2021/05/20/JavaWeb%E2%80%94%E2%80%94JSTL%E6%A0%87%E7%AD%BE%E5%BA%93/</id>
    <published>2021-05-20T08:43:27.000Z</published>
    <updated>2021-05-20T09:57:35.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、JSTL标签库"><a href="#一、JSTL标签库" class="headerlink" title="一、JSTL标签库"></a>一、JSTL标签库</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><ul><li><p>JSTL标签库全称是指JSP Standard Tag Library JSP标准标签库。是一个不断完善的开放源代码的JSP标签库。 EL表达式主要是为了替换jsp中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个jsp页面变得更佳简洁。</p></li><li><p>JSTL由五个不同功能的标签库组成。</p></li></ul><table><thead><tr><th>功能范围</th><th>URI</th><th>前缀</th></tr></thead><tbody><tr><td>核心标签库–重点</td><td><a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a></td><td>c</td></tr><tr><td>格式化</td><td><a href="http://java.sun.com/jsp/jstl/fmt">http://java.sun.com/jsp/jstl/fmt</a></td><td>fmt</td></tr><tr><td>函数</td><td><a href="http://java.sun.com/jsp/jstl/functions">http://java.sun.com/jsp/jstl/functions</a></td><td>fn</td></tr><tr><td>数据库(不使用)</td><td><a href="http://java.sun.com/jsp/jstl/sql">http://java.sun.com/jsp/jstl/sql</a></td><td>sql</td></tr><tr><td>XML(不使用)</td><td><a href="http://java.sun.com/jsp/jstl/xml">http://java.sun.com/jsp/jstl/xml</a></td><td>x</td></tr></tbody></table><h2 id="2-JSTL标签库的使用步骤"><a href="#2-JSTL标签库的使用步骤" class="headerlink" title="2. JSTL标签库的使用步骤"></a>2. JSTL标签库的使用步骤</h2><ul><li>先导入JSTL的jar包。</li><li>使用taglib指令引入标。</li></ul><img src="https://pic.imgdb.cn/item/60a62f556ae4f77d357de83a.png" style="zoom:80%;" /><h2 id="3-set标签"><a href="#3-set标签" class="headerlink" title="3. set标签"></a>3. set标签</h2><img src="https://pic.imgdb.cn/item/60a62f396ae4f77d357d5174.png" style="zoom:80%;" /><h2 id="4-if标签"><a href="#4-if标签" class="headerlink" title="4. if标签"></a>4. if标签</h2><img src="https://pic.imgdb.cn/item/60a62f1d6ae4f77d357cb817.png" style="zoom:67%;" /><h2 id="5-choose标签"><a href="#5-choose标签" class="headerlink" title="5. choose标签"></a>5. choose标签</h2><p><img src="https://pic.imgdb.cn/item/60a62f096ae4f77d357c3fb8.png"></p><h2 id="6-forEach标签"><a href="#6-forEach标签" class="headerlink" title="6. forEach标签"></a>6. forEach标签</h2><p><img src="https://pic.imgdb.cn/item/60a62ee86ae4f77d357b81fe.png"></p><h2 id="7-forEach标签总结"><a href="#7-forEach标签总结" class="headerlink" title="7. forEach标签总结"></a>7. forEach标签总结</h2><img src="https://pic.imgdb.cn/item/60a62ed66ae4f77d357b161e.png" style="zoom:80%;" />]]></content>
    
    
    <summary type="html">JavaWeb[尚硅谷] Summary for videos</summary>
    
    
    
    <category term="知也无涯(学习)" scheme="http://example.com/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JSTL标签库" scheme="http://example.com/tags/JSTL%E6%A0%87%E7%AD%BE%E5%BA%93/"/>
    
  </entry>
  
</feed>
