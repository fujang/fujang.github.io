<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java基础全套教程[尚硅谷宋红康] Summary for videos | Hexo</title><meta name="keywords" content="Java"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础全套教程[尚硅谷宋红康] Summary for videos">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础全套教程[尚硅谷宋红康] Summary for videos">
<meta property="og:url" content="http://example.com/2021/05/06/Java%E5%9F%BA%E7%A1%80%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AE%8B%E7%BA%A2%E5%BA%B7-Summary-for-videos/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java基础全套教程[尚硅谷宋红康] Summary for videos">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ae01.alicdn.com/kf/Ue5edb0f19a2e4271ae53123db8ea53e8N.jpg">
<meta property="article:published_time" content="2021-05-06T07:41:40.000Z">
<meta property="article:modified_time" content="2021-05-11T08:08:31.148Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ae01.alicdn.com/kf/Ue5edb0f19a2e4271ae53123db8ea53e8N.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/05/06/Java%E5%9F%BA%E7%A1%80%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AE%8B%E7%BA%A2%E5%BA%B7-Summary-for-videos/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础全套教程[尚硅谷宋红康] Summary for videos',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-11 16:08:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-filter-gitcalendar/lib/gitcalendar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">69</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">53</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> Archives</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Timeline</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-bars"></i><span> Literature</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa fa-tasks"></i><span> Anime</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ae01.alicdn.com/kf/U78919e76605248dd90287b2a78a8bb81C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> Archives</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Timeline</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-bars"></i><span> Literature</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa fa-tasks"></i><span> Anime</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础全套教程[尚硅谷宋红康] Summary for videos</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-05-06T07:41:40.000Z" title="Created 2021-05-06 15:41:40">2021-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-05-11T08:08:31.148Z" title="Updated 2021-05-11 16:08:31">2021-05-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E4%B9%9F%E6%97%A0%E6%B6%AF-%E5%AD%A6%E4%B9%A0/">知也无涯(学习)</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础全套教程[尚硅谷宋红康] Summary for videos"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java基础全套教程-尚硅谷宋红康"><a href="#Java基础全套教程-尚硅谷宋红康" class="headerlink" title="Java基础全套教程[尚硅谷宋红康]"></a>Java基础全套教程[尚硅谷宋红康]</h1><h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><ul>
<li>文档注释：注释内容可以被JDK提供的工具javadoc(只提取文档注释)所解析，生成一套以网页文件形式体现的该程序的说明文档。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Uc3ee66fa98024eccbba7772e08b50a994.jpg" alt="image-20210508203700320" style="zoom: 80%;" />

<ul>
<li>保留字(现在非关键字，但是以后新版本可能是)：goto、const。关键字如下。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td>用于定义数据类型的关键字</td>
<td align="left">class、interface、enum、byte、short、int、long、float、double、char、boolean、void</td>
</tr>
<tr>
<td>用于定义流程控制的关键字</td>
<td align="left">if、else、switch、case、default、while、do、for、break、continue、return</td>
</tr>
<tr>
<td>用于定义访问权限修饰符的关键字</td>
<td align="left">private、protected、public</td>
</tr>
<tr>
<td>用于定义类、函数、变量修饰符的关键字</td>
<td align="left">abstract、final、static、synchronized</td>
</tr>
<tr>
<td>用于定义类与类之间关系的关键字</td>
<td align="left">extends、implements</td>
</tr>
<tr>
<td>用于定义建立实例及引用实例，判断实例的关键字</td>
<td align="left">new、this、super、instanceof</td>
</tr>
<tr>
<td>用于异常处理的关键字</td>
<td align="left">try、catch、finally、throw、throws</td>
</tr>
<tr>
<td>用于包的关键字</td>
<td align="left">package、import</td>
</tr>
<tr>
<td>其他修饰符关键字</td>
<td align="left">native、strictfp、transient、volatile、assert</td>
</tr>
<tr>
<td>用于定义数据类型值的字面值</td>
<td align="left">true、false、null</td>
</tr>
</tbody></table>
<ul>
<li><p>标识符：由英文字母、数字、下划线、$组成。</p>
</li>
<li><p>标识符命名规范：</p>
<ul>
<li>包名：所有单词都小写。</li>
<li>类名：大驼峰。</li>
<li>变量名、方法名：小驼峰。</li>
<li>常量名：单词之间用下划线，全部大写。</li>
</ul>
</li>
<li><p>boolean类型数据只允许取值true和false，无null。不可以使用0或非0的整数替代false和true，这点和C语言不同。</p>
</li>
<li><p>自动类型转换：容量小的类型自动转换为容量大的数据类型。容量代表数的范围的大小，而不是内存的大小。</p>
</li>
<li><p>常用进制：</p>
<ul>
<li>二进制：以0b或0B开头。 </li>
<li>八进制：以数字0开头表示。</li>
<li>十六进制：0-9及A-F， 以0x或0X开头表示。此处的A-F不区分大小写。</li>
</ul>
</li>
<li><p><code>&gt;&gt;&gt;</code>代表无符号右移，无论最高位为0或者1，都由0来补。</p>
</li>
</ul>
<ul>
<li>Scanner类使用步骤：<ul>
<li>导包：<code>import java.util.Scanner</code>。</li>
<li>Scanner的实例化：<code>Scanner scan = new Scanner(System.in)</code>。</li>
<li>调用Scanner类的相关方法，获取指定类型的变量：<code>int num = scan.nextInt()</code>。</li>
<li>获取字符串：<code>scan.next()</code>。</li>
<li>获取浮点数：<code>scan.nextDouble()</code>。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U24d1f6d0d3aa4064a6da4a497952aad31.jpg" alt="image-20210508204904349" style="zoom:80%;" />

<ul>
<li>带标签的continue和break示例如下。标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面，演示break如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Uc3ddb120cee34f1099883337077e3dcbl.jpg" alt="image-20210508204957940" style="zoom:80%;" />

<ul>
<li>第一例运行结果为如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U8306a748080643ebbf8f9ec8667821f08.jpg" alt="image-20210508205015602" style="zoom:80%;" />

<ul>
<li>演示continue如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U0fd0aaa38c5842f880d8624f3777e829F.jpg" alt="image-20210508205530462" style="zoom:80%;" />

<ul>
<li>第二例运行结果为如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U6d5b8f70bbd647609a7382112a22d2493.jpg" alt="image-20210508205550482" style="zoom:80%;" />

<ul>
<li>Eclipse缩写与常用快捷键：<ul>
<li><code>main </code>：<code>public static void main(String[] args) &#123;&#125;</code>。</li>
<li><code>syso</code>：<code>System.out.println()</code>。</li>
<li><code>alt+/</code>：补全提示。</li>
<li><code>Ctrl+鼠标点击</code>：查看源代码。</li>
<li><code>alt+/</code>：补全代码。</li>
<li><code>ctrl+/</code>：注释。</li>
<li><code>ctrl+\</code>：取消斜杠。</li>
<li><code>ctrl+o</code>：查找类中的结构。</li>
<li><code>ctrl+d</code>：删除当前行。</li>
<li><code>ctrl+1</code>：快速修复。</li>
<li><code>ctrl+shif+o</code>：快速导包。</li>
</ul>
</li>
</ul>
<h2 id="二、数组语法"><a href="#二、数组语法" class="headerlink" title="二、数组语法"></a>二、数组语法</h2><ul>
<li>数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型。</li>
<li>数组静态初始化：<ul>
<li><code>int[] a = new int[]&#123;1,2,3&#125;</code>。</li>
<li><code>int[] a = &#123;1,2,3&#125;</code>：类型推断，初始化和声明在一行时可以省略new。</li>
</ul>
</li>
<li>数组动态初始化：<code>String[] names = new String[5]</code>。</li>
<li>数组长度：<code>a.length</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>数组元素类型</th>
<th>默认初始化值</th>
</tr>
</thead>
<tbody><tr>
<td>整型</td>
<td>0</td>
</tr>
<tr>
<td>浮点型</td>
<td>0.0</td>
</tr>
<tr>
<td>char型</td>
<td>0或<code>&#39;\u0000&#39; </code>而非<code>&#39;0&#39;</code></td>
</tr>
<tr>
<td>布尔型</td>
<td>false</td>
</tr>
<tr>
<td>引用数据类型</td>
<td>null</td>
</tr>
</tbody></table>
<ul>
<li>内存模型如下。</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/U2118be4b65af45d6851990e0b00cdf49o.jpg" alt="image-20210508210440947"></p>
<ul>
<li>一维数组的内存解析如下。</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/Ue822a3c6a38e4b0ebda9847447d145dbe.jpg" alt="image-20210508211346538"></p>
<ul>
<li><p>二维数组静态初始化：<code>int[][] a = new int[][] &#123;&#123;1,2&#125;,&#123;1,2,3&#125;,&#123;1,2&#125;&#125;</code>，<code>a[0].length=2</code>，<code>a[1].length=3</code>。</p>
</li>
<li><p>二维数组动态初始化：</p>
<ul>
<li><code>String[][] a = new String[3][2]</code>。</li>
<li><code>String[][] a = new String[3][]</code>。</li>
</ul>
</li>
<li><p>对于<code>int arr[][] = new int[4][3]</code>的默认值：</p>
<ul>
<li><code>arr[0]</code>：地址值。</li>
<li><code>arr[0][0]</code>：0。</li>
</ul>
</li>
<li><p>对于<code>int arr[][] = new int[4][]</code>的默认值：</p>
<ul>
<li><code>arr[0]</code>：null。</li>
<li><code>arr[0][0]</code>：报错。</li>
</ul>
</li>
<li><p>二维数组的内存解析如下。</p>
</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/U9517af7fbe1d4bb5bca580d6cb7b62adf.jpg" alt="image-20210508211817244"></p>
<ul>
<li><code>a2=a1</code>：把a1的地址给了a2，这样两个变量指向的值一致，那么当修改a2时，a1的值也会改变，此操作不能被称为数组的复制。</li>
<li>字符串比较：<code>a.equals(b)</code>。</li>
<li>Arrays工具类如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Uec0e0a48a8ac4bf29b17c24221cf6aceg.jpg" style="zoom:80%;" />

<ul>
<li>数组中常见异常：<ul>
<li><code>ArrayIndexOutOfBoundsException</code>：数组角标越界异常。</li>
<li><code>NullPointerException</code>：空指针异常。</li>
</ul>
</li>
</ul>
<h2 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h2><ul>
<li>面向过程：POP。面向对象：OOP。</li>
<li><code>Person p3=p1</code>：将p1变量保存的对象的地址赋值给p3，导致p1和p3指向了堆空间中的同一个对象实体。</li>
<li>对象的内存解析如下。</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/U4742946ee4b7401f81ba824058aa48baN.jpg" alt="image-20210508212434620"></p>
<table>
<thead>
<tr>
<th>属性类型</th>
<th>默认初始化值</th>
</tr>
</thead>
<tbody><tr>
<td>整形(byte、short、int、long)</td>
<td>0</td>
</tr>
<tr>
<td>浮点型(float、double)</td>
<td>0.0</td>
</tr>
<tr>
<td>字符型(char)</td>
<td>0或<code>&#39;\u0000&#39; </code>而非<code>&#39;0&#39;</code></td>
</tr>
<tr>
<td>布尔型(boolean)</td>
<td>false</td>
</tr>
<tr>
<td>引用(类、数组、接口)</td>
<td>null</td>
</tr>
</tbody></table>
<ul>
<li><p>在内存中加载的位置：</p>
<ul>
<li>属性：加载到堆空间中(非static)。</li>
<li>局部变量：加载到栈空间。</li>
</ul>
</li>
<li><p>引用类型的变量，只可能存储两类值：null或地址值。</p>
</li>
<li><p>匿名对象：创建的对象没有显式赋给一个变量名，即为匿名对象。匿名对象只能调用一次，<code>new Phone().send()</code>。</p>
</li>
<li><p>可变个数形参的方法：jdk5.0新增的内容，格式：数据类型 … 变量名，<code>public void show(String ... strs) &#123;&#125;</code>，可以为0到无穷个参数。</p>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Uead7d6ab50414950b6c7155df2d12e25i.jpg" alt="image-20210507211600188" style="zoom:80%;" />

<ul>
<li>这两种方法默认一样，不能共存，不构成重载。在一个方法的形参位置，最多只能声明一个可变个数形参，可变个数形参在方法中必须声明在末尾，可变参数方法的使用与方法参数部分使用数组是一致的，如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U466a5b3487d34b15ba7996d744ef7a53E.jpg" alt="image-20210507211733967" style="zoom:80%;" />

<ul>
<li>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参。</li>
<li>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参。</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>内部类</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空闲</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<ul>
<li><p>修饰类只能用空缺或public。public类可以在任意地方被访问，空缺类只可以被同一个包内部的类访问。</p>
</li>
<li><p>构造器：不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值，可以被权限修饰符修饰。一旦显式定义了构造器，则系统不再提供默认构造器。父类的构造器不可被子类继承。</p>
</li>
<li><p>JavaBean是一种Java语言写成的可重用组件，所谓JavaBean，是指符合如下标准的Java类：</p>
<ul>
<li>类是公共的。</li>
<li>有一个无参的公共的构造器。</li>
<li>有属性，且有对应的get、set方法。</li>
</ul>
</li>
<li><p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</p>
</li>
<li><p>this：它在方法内部使用，即这个方法所属对象的引用；它在构造器内部使用，表示该构造器正在初始化的对象。可以在类的构造器中使用<code>this(形参列表)</code>的方式，调用本类中重载的其他的构造器。构造器中不能通过<code>this(形参列表)</code>的方式调用自身构造器。<code>this(形参列表)</code>必须声明在类的构造器的首行。在类的一个构造器中，最多只能声明一个<code>this(形参列表)</code>。</p>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U599343f0a19442a38a7709c870099c1ft.jpg" alt="image-20210507212848577" style="zoom:80%;" />

<ul>
<li><p>package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包(若缺省该语句，则指定为无名包)。它的格式为：<code>package 顶层包名.子包名</code>。每<code>.</code>一次，就代表一层文件目录。同一个包下，不能命名同名的接口、类，不同的包下，可以命名同名的接口、类。包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式。</p>
<ul>
<li>包可以包含类和子包，划分项目层次，便于管理。</li>
<li>解决类命名冲突的问题。</li>
<li>控制访问权限。</li>
</ul>
</li>
<li><p>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。如果已经导入所有java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。</p>
</li>
<li><p>import static组合的使用：调用指定类或接口下的静态的属性或方法。</p>
</li>
<li><p>java中的JUnit单元测试：</p>
<ul>
<li>选中当前工程-&gt;build path-&gt;add libraries-&gt;JUnit4-&gt;finish。</li>
<li>类的要求：此类为public。此类提供公共的无参构造器。</li>
<li>声明单元测试方法，方法的权限为public，返回值类型为void，无形参。</li>
<li>此方法上需要声明注解@Test并导入org.junit.Test包。</li>
<li>双击方法名，选择运行方法。</li>
</ul>
</li>
<li><p>1个类只能有一个父类。如果没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类。</p>
</li>
<li><p>子类中把父类中的private方法改为public方法不叫重写，不会覆盖private方法，如果在父类中调用方法，会调用private方法，而不会调用public方法。</p>
</li>
<li><p>子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。</p>
</li>
<li><p>如父类是void返回值类型，则子类也只能是void；若父类是A类型，则子类的返回类型只能是A类或者A的子类。</p>
</li>
<li><p>子类重写的方法抛出异常类型不大于父类被重写的方法抛出的异常类型。</p>
</li>
<li><p>子类和父类同名同参数的方法都是非static，则考虑为重写；若都是static，则不是重写。</p>
</li>
<li><p>super可用于访问父类中定义的属性：</p>
<ul>
<li>super可用于调用父类中定义的成员方法。</li>
<li>super可用于在子类构造器中调用父类的构造器。</li>
</ul>
</li>
<li><p>关于super调用构造器：</p>
<ul>
<li>我们可以在子类的构造器中显式的使用super(形参列表)的方式调用父类声明的指定的构造器。</li>
<li>必须生命在子类构造器的首行。</li>
<li>类的构造器中，super(形参列表)和this(形参列表)只能二选一，不能同时出现。</li>
<li>在构造器的首行，如果没有显式声明this或super，则默认为调用父类中的空参构造器。</li>
<li>在类的多个构造器中，至少有一个类使用了super(形参列表)调用父类中的构造器。</li>
</ul>
</li>
<li><p>对象的多态性：父类的引用指向子类的对象，<code>Person p1 = new Man()</code>。</p>
</li>
<li><p>多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法——虚拟方法的调用。有了对象的多态性后，我们在编译期只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。总结：编译看左边，运行看右边。对象的多态性只适用于方法，不适用于属性(编译和运行都看左边)。</p>
</li>
<li><p>对于重载：在方法调用之前，编译器就确定了要调用的方法，此为静态绑定。对于多态，在方法调用的那一刻，编译器才会确定要调用的具体方法，此为动态绑定。</p>
</li>
<li><p><code>x instanceof A</code>：检验x是否为类A的对象或子类，返回值为boolean型。</p>
</li>
<li><p>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，需要先进行instanceof的判断，为true则向下转型。</p>
</li>
<li><p>程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。垃圾回收机制回收任何对象之前，总会先调用它的finalize方法，永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</p>
</li>
<li><p>Object类只声明了一个空参构造器。</p>
<ul>
<li><code>equals(Object obj)</code>：Object中equals()方法和==作用相同，我们一般需要对equals()进行重写。</li>
<li><code>toString()</code>：在Object类中定义，其返回值是String类型，返回类名和它的引用地址。在进行String与其它类型数据的连接操作时，自动调用toString()方法。可以根据需要在用户自定义类型中重写toString()方法。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<ul>
<li>表格中的前六行的包装类属于父类Number的子类。</li>
<li>调用包装类的xxxValue()。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Uf60364d7c6e44bfc97b723d41af4037ex.jpg" alt="image-20210508232052004" style="zoom:80%;" />

<ul>
<li>在JDK5之中增加了新特性：自动装箱与自动拆箱。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Ud9404e2b987e4879b634b13c5176a263z.jpg" alt="image-20210508232247854" style="zoom:80%;" />

<ul>
<li><p>静态变量加载早于对象的创建，随着类的加载而加载。</p>
</li>
<li><p>静态方法中只能调用静态方法和静态属性。非静态方法中既可以调用非静态方法和属性，也可以调用静态的方法和属性。在静态方法中，不能使用this和super。</p>
</li>
<li><p>静态代码块：用static修饰的代码块。</p>
<ul>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</li>
<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>静态代码块的执行要先于非静态代码块。</li>
<li>静态代码块随着类的加载而加载，且只执行一次。</li>
</ul>
</li>
<li><p>非静态代码块：没有static修饰的代码块。</p>
<ul>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>除了调用非静态的结构外，还可以调用静态的变量或方法。</li>
<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li>
</ul>
</li>
<li><p>赋值的先后顺序：</p>
<ol>
<li>默认初始化。</li>
<li>显示初始化/在代码块中初始化。</li>
<li>构造器初始化。</li>
<li>通过对象赋值。</li>
</ol>
</li>
<li><p>final关键字：</p>
<ul>
<li>final标记的类不能被继承。</li>
<li>final标记的方法不能被子类重写。</li>
<li>final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。</li>
<li>final属性可以考虑的赋值位置有：显式初始化、代码块中初始化、构造器中初始化。</li>
</ul>
</li>
<li><p>static final：用来修饰属性，为全局变量。</p>
</li>
<li><p>abstract关键字：</p>
<ul>
<li>修饰类、方法。</li>
<li>修饰类：此类不能实例化，抽象类一定有构造器，便于子类实例化时调用。开发时会提供抽象类的子类，让子类对象实例化，完成相关的操作。</li>
<li>修饰方法：只有方法的声明，没有方法体。含有抽象方法的类一定是一个抽象类，反之抽象类中可以没有抽象方法。必须重写了全部的抽象方法后才可以实例化，否则仍是个abstract修饰的抽象类。</li>
<li>abstract不能修饰私有方法、静态方法、final方法、final类。</li>
</ul>
</li>
<li><p>匿名类如下。</p>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Uc516b97e3b7a4180825dce93050330a5O.jpg" alt="image-20210508234251974" style="zoom:80%;" />

<ul>
<li>UML类图：+表示public类型，-表示private类型，#表示protected类型。方法的写法:  <code>方法的类型(+、-) 方法名(参数名： 参数类型)：返回值类型</code>。若方法有下划线表示为构造器。</li>
<li>interface关键字：<ul>
<li>JDK7之前只能定义全局常量和抽象方法。public static final(可以省略)，public abstract(可以省略)。</li>
<li>JDK8 还可以定义静态方法、默认方法。</li>
<li>若实现了所有抽象方法，则为一个类，否则则为一个抽象类。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U59a609e3c6634255987b725234f3165cT.jpg" alt="image-20210509005134492" style="zoom:80%;" />

<ul>
<li>接口中不能定义构造器。</li>
<li>java类可以实现多个接口，接口可以多继承，格式为<code>class AA extends BB implements CC,DD,EE &#123;&#125;</code>。</li>
<li>接口在使用上体现了多态性。例如：usb为接口，phone为实现接口的类，则可以往方法形参为usb的接口传入phone的对象。</li>
<li>接口中的静态方法，只能通过接口调用。通过实现类的对象，可以调用接口中的默认方法。如果实现类中重写了接口中的默认方法，则调用时，仍然调用的是重写的方法。</li>
<li>如果子类继承的父类和实现的接口中声明了同名同参数的方法，那么在子类没有重写该方法的情况下，默认调用的是父类中同名同参数的方法(类优先原则)。</li>
<li>如果实现了多个接口，而接口中有多个定义了同名同参数的默认方法，那么在实现类没有重写该方法的情况下，编译器会报错(接口冲突)。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U5007ac7cc1b8495bba629705db636f50X.jpg" alt="image-20210509005934399" style="zoom:80%;" />

<ul>
<li>运行结果如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U02ec221a75324f398259911c758dbb8cF.jpg" alt="image-20210509005815338" style="zoom:80%;" />

<ul>
<li>内部类：<ul>
<li>一方面，作为外部类的成员：<ul>
<li>调用外部类的结构。</li>
<li>可以被static修饰。</li>
<li>可以被四种权限修饰。</li>
</ul>
</li>
<li>一方面，作为一个类：<ul>
<li>可以定义属性、方法、构造器等。</li>
<li>可以被final修饰，表示不能被继承。</li>
<li>可以被abstract修饰。</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U2576d5de31a54376a6098cc30830ed49e.jpg" alt="image-20210509003159724" style="zoom:80%;" />

<ul>
<li>关于内部类中的方法中的重名变量调用如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Uceaa537e1353432b8280b3c5b801386cq.jpg" alt="image-20210509003726163" style="zoom:80%;" />

<ul>
<li>关于内部类调用外部类重名重形参方法如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U7ccb324d0b0b4c05b99dc9a3620c3b526.jpg" alt="image-20210509004026036" style="zoom:80%;" />

<ul>
<li>在局部内部类的方法中，如果调用局部内部类所声明的方法中的局部变量，要求此局部变量声明为final的。在JDK7及之前，要求显式声明为final；在JDK8及之后，可以省略final的声明。</li>
</ul>
<h2 id="四、设计模式"><a href="#四、设计模式" class="headerlink" title="四、设计模式"></a>四、设计模式</h2><ul>
<li>MVC设计模式：MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。</li>
<li>模板方法设计模式：抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。 解决的问题： <ul>
<li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</li>
</ul>
</li>
<li>接口的应用——代理模式：代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其 他对象提供一种代理以控制对这个对象的访问。</li>
<li>接口的应用——工厂模式：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</li>
<li>单例设计模式：所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。 如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象， 静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</li>
<li>饿汉式如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U32e079480954435c89ea265d0a34aacbN.jpg" alt="image-20210511144942535" style="zoom:80%;" />

<ul>
<li>懒汉式如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Ub10d588483764a9b982851a87f5f6857D.jpg" alt="image-20210511145004200" style="zoom:80%;" />

<ul>
<li>由于懒汉式存在线程安全问题，因此修改如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U0f5f2d6c2be7405cae9edc8bf010e4efg.jpg" alt="image-20210511145144640" style="zoom:80%;" />

<ul>
<li>饿汉式：对象加载时间过长，是线程安全的。</li>
<li>懒汉式：延迟对象的创建，线程安全。</li>
<li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的 产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</li>
</ul>
<h2 id="五、异常处理"><a href="#五、异常处理" class="headerlink" title="五、异常处理"></a>五、异常处理</h2><ul>
<li>捕获错误最理想的是在编译期间，但有的错误只在运行时才会发生，如下标越界等。因此异常的分类分为：编译时异常和运行时异常。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U7acaf06e8d7546ee897d65b26fc21c08u.jpg" alt="image-20210508235801240" style="zoom: 80%;" />

<ul>
<li>异常的处理：抓抛模型：<ul>
<li>抛：程序在正在执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一单抛出对象以后，其后的代码就不再执行。关于异常对象的产生：系统自动生成的异常对象、手动生成一个异常对象，并抛出(throw)。</li>
<li>抓：try-catch-finally、throws。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U3aa28d4f1f7d499b8e35de0520d9134ex.jpg" alt="image-20210509000944164" style="zoom:80%;" />

<ul>
<li>try-catch-finally：<ul>
<li>finally是可选的。</li>
<li>使用try将可能出现的异常包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，取catch中进行匹配。</li>
<li>一但try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一但处理完成，就跳出当前的try-catch结构。继续执行其后面的代码。</li>
<li>catch中的异常类型如果没有子父类关系，则声明顺序无所谓。如果存在子父类关系，则要求子类先声明，父类后声明，否则会报错。</li>
<li>常用的异常对象处理的方式：String getMessage()、printStackTrace()。</li>
<li>在try中声明的变量，出了try结构后，就不能再被调用。</li>
<li>使用try-catch-finally处理编译时异常，是使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常延迟到运行时出现。</li>
<li>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要自己手动的进行资源的释放。此时资源的释放，就需要声明在finally中。</li>
<li>由于运行时异常比较常见，我们就通常不真如运行时异常编写try-catch-finally了。针对编译时异常，我们一定要考虑异常的处理。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U39d5e14c92a14dbcbd03c83ab9f459e9T.jpg" alt="image-20210509001207676" style="zoom:80%;" />

<ul>
<li><p>throws+异常类型：</p>
<ul>
<li>写在方法的声明处，指明此方法执行中可能会抛出的异常类型。</li>
<li>一但方法执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后的异常类型时就会抛出，异常代码后续的代码就不再执行。throws只是将异常抛出给了方法的调用者，并没有真正将异常处理掉。</li>
</ul>
</li>
<li><p>如果父类中被重写的方法中没有throws处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，就必须用try-catch-finally方式处理。</p>
</li>
<li><p>执行的方法a中，又先后调用了另外几个方法，这几个方法是递进执行的。我们建议这几个方法使用throws的方式进行处理，而执行方法a时可以考虑用try-catch-finally方式进行处理。</p>
</li>
<li><p>自定义异常：</p>
<ul>
<li>继承现有的异常结构。</li>
<li>提供全局常量serialVersionUID。</li>
<li>提供重载的构造器。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U8d54fc55401b4a3187f336813b16c2fdM.jpg" alt="image-20210509002351690" style="zoom:80%;" />

<h2 id="六、多线程"><a href="#六、多线程" class="headerlink" title="六、多线程"></a>六、多线程</h2><ul>
<li>程序(program)：是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段静态的代码，静态对象。</li>
<li>进程(process)：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。程序是静态的，进程是动态的。进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。</li>
<li>线程(thread)：进程可进一步细化为线程，是一个程序内部的一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的。</li>
<li>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。一个进程中的多个线程共享相同的内存单元/内存地址空间。它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</li>
<li>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</li>
<li>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</li>
<li>Java语言的JVM允许程序运行多个线程，它通过<code>java.lang.Thread</code>类来体现。</li>
<li>多线程的创建方式：<ul>
<li>方法一：继承于Thread类。</li>
<li>方法二：实现Runnable接口。</li>
<li>方法三：实现Callable接口。</li>
<li>方法四：使用线程池。</li>
</ul>
</li>
<li>继承于Thread类：<ul>
<li>创建一个继承于Thread类的子类。</li>
<li>重写Thread的run()方法(将此线程执行的操作声明在run方法中)。</li>
<li>创建Thread类的子类的对象。</li>
<li>通过此对象调用start()方法(启动当前线程、调用当前线程的run方法)。</li>
<li>我们不能通过直接调用run()的方式启动线程。</li>
<li>再启动一个线程，不可以让已经start()的线程去执行，否则会报异常，我们需要重新创建一个线程的对象去执行。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Ua9715fbcae9746428ed8bc6035411af5x.jpg" alt="image-20210509143351831" style="zoom:80%;" />

<ul>
<li>创建Thread类的匿名子类的方式如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Ubb007c97d6c14f8cb56baf8ef82141c11.jpg" alt="image-20210509143745307" style="zoom:80%;" />

<ul>
<li>测试Thread中的常用方法：<ol>
<li>start()：启动当前的线程，调用当前线程的run()方法。</li>
<li>run()：通常需要重写Thread的此方法，将创建的线程需要执行的操作生命在此方法中。</li>
<li>currentThread()：静态方法，返回执行当前代码的线程。</li>
<li>getName()：获取当前线程的名字。</li>
<li>setName()：设置当前线程的名字。</li>
<li>yield()：释放当前CPU的执行权。</li>
<li>join()：在线程a中调用线程b的join()，此时线程a就会进入阻塞状态，知道线程b完全执行完之后，线程a才结束阻塞状态。</li>
<li>stop()：已过时，当调用此方法时，强制结束当前进程。</li>
<li>sleep(long millitime)：让当前线程睡眠指定的millitime毫秒，在指定的millitime毫秒时间内，当前线程是阻塞状态。</li>
<li>isAlive()：判断当前线程是否存活。</li>
</ol>
</li>
<li>线程的优先级：<ul>
<li>MAX_PRIORITY：10。</li>
<li>MIN_PRIORITY：1。</li>
<li>NORM_PRIORITY(默认优先级)：5。</li>
<li>获取线程的优先级：getPriority()。</li>
<li>设置线程的优先级：setPriority(int p)。</li>
<li>说明：高优先级的线程要抢占低优先级的CPU执行权。但只是从概率上讲，高优先级的线程高概率的情况下被执行，并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。</li>
</ul>
</li>
<li>实现Runnable接口的类：<ul>
<li>创建一个实现了Runnable接口的类。</li>
<li>实现类去实现Runnable中的抽象方法run()。</li>
<li>创建实现类的对象。</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象。</li>
<li>通过Thread类的对象调用start()。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Ud48cc59516514c22bc5fdbcfdf29e98fR.jpg" alt="image-20210509150024953" style="zoom:80%;" />

<ul>
<li>下图中三个线程共用一个runnableTest对象。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U12e0222a876a46ecad345dc3d6be45d3P.jpg" alt="image-20210509150140613" style="zoom:80%;" />

<ul>
<li><p>比较上述两种创建线程的方式：</p>
<ul>
<li>开放中优先选择实现Runnable接口的方式。</li>
<li>实现接口的方式没有类的单继承的局限性。</li>
<li>实现的方式更适合来处理多个线程有共享数据的情况。</li>
<li>两种方法都要重写run()方法。</li>
</ul>
</li>
<li><p>JDK中用Thread.State类定义了线程的几种状态。要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：</p>
<ul>
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源。</li>
<li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态，run()方法定义了线程的操作和功能。</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态。</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。</li>
</ul>
</li>
<li><p>synchronized关键字：</p>
<ul>
<li>问题：线程安全问题。</li>
<li>原因：在某个线程操作的过程中，操作尚未完成，此时其他线程参与进来，也操作数据。</li>
<li>解决方法：让一个线程操作数据时其他线程不能参与进来，直到此线程操作完成后其他线程再进来。这种情况下即便此线程出现了阻塞，也不能改变。</li>
<li>方式一：同步代码块，<code>synchronized(同步监视器) &#123;需要被同步的代码&#125;</code>，说明：<ul>
<li>操作共享数据的代码，即为需要被同步的代码。</li>
<li>共享数据：多个线程共同操作的变量。</li>
<li>同步监视器：俗称锁，任何一个对象都可以充当锁，要求多个线程必须同用一把锁。</li>
<li>在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</li>
</ul>
</li>
<li>方式二：同步方法，synchronized还可以放在方法声明中，表示整个方法为同步方法。<ul>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li>
<li>非静态的同步方法，同步监视器是this。</li>
<li>静态的同步方法，同步监视器是当前类本身。</li>
</ul>
</li>
<li>同步的方式解决了线程安全问题，但是操作同步代码块时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。</li>
</ul>
</li>
<li><p>线程的死锁问题：</p>
<ul>
<li>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。</li>
<li>解决方法：专门的算法、原则，尽量减少同步资源的定义，尽量避免嵌套同步。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Uf902cd1fd2654f6b847894333607294bm.jpg" alt="image-20210509153840311" style="zoom:80%;" />

<ul>
<li>Lock(锁)：<ul>
<li>从JDK5开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li>
<li>ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U2aa68d7f11df4843b0dd1df9e92a92e74.jpg" alt="image-20210510100011368" style="zoom:80%;" />

<ul>
<li><p>synchronized与lock的异同：</p>
<ul>
<li>二者都可以解决线程安全问题。</li>
<li>synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器。</li>
<li>lock需要手动的启动同步(lock)，同时结束同步也需要手动的实现(unlock)。</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁。</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性</li>
<li>使用的优先顺序：Lock、同步代码块、同步方法。</li>
</ul>
</li>
<li><p>线程的通信：</p>
<ul>
<li>wait()与notify()和notifyAll() <ul>
<li>wait()：令当前线程挂起并放弃CPU、同步资源并等待，调用方法的必要条件为当前线程必须具有对该对象的监控权(加锁)。使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</li>
<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待。当前线程必须具有对该对象的监控权(加锁)。</li>
<li>notifyAll()：唤醒正在排队等待资源的所有线程结束等待。</li>
</ul>
</li>
<li>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报 java.lang.IllegalMonitorStateException异常。</li>
<li>因为这三个方法必须为有锁对象调用，而任意对象都可以作为synchronized的同步锁， 因此这三个方法只能在Object类中声明。</li>
</ul>
</li>
<li><p>sleep和wait的异同：</p>
<ul>
<li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</li>
<li>不同点：<ul>
<li>两个方法的声明位置不同，Thread类中声明sleep，Object类中声明wait。</li>
<li>调用的要求不同，sleep可以在任何需要的场景下调用，wait必须在同步代码块或同步方法中调用。</li>
<li>关于是否释放同步监视器：如果两个方法都是同在同步代码块或同步方法中，sleep不会释放同步监视器，而wait会释放同步监视器。</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Ue212cd16a2d44ba6961748b513df2adfR.jpg" alt="image-20210511144255556" style="zoom:80%;" />

<ul>
<li><p>与使用Runnable相比，Callable功能更强大些：</p>
<ul>
<li>可以存在返回值。</li>
<li>可以抛出异常。</li>
<li>可以支持泛型的返回值。</li>
<li>需要借助Future Task类，比如获取返回结果。</li>
<li>Callable实现call方法。</li>
</ul>
</li>
<li><p>实现Callable接口的类：</p>
<ul>
<li>创建一个实现Callable的实现类。</li>
<li>实现call方法，将此线程需要执行的操作声明在call中。</li>
<li>创建Callable接口实现类的对象。</li>
<li>将此Callable接口实现类的对象作为参数传递到Future Task类的构造器中，创建Future Task的对象。</li>
<li>将Future Task的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法。</li>
<li>可以根据需要从Future Task获取返回值。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U5cd53becc6984eb088b60aca4a461acdd.jpg" alt="image-20210510204801375" style="zoom:80%;" />

<ul>
<li>Callable中的call方法：<ul>
<li>call可以有返回值。</li>
<li>call可以抛出异常，被外层的操作捕获，获取异常的信息。</li>
<li>Callable是支持泛型的。</li>
</ul>
</li>
<li>使用线程池：<ul>
<li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。</li>
<li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li>
<li>好处：<ul>
<li>提高响应速度(减少了创建新线程的时间)。</li>
<li>降低资源消耗(重复利用线程池中线程，不需要每次都创建)。</li>
<li>便于线程管理。</li>
</ul>
</li>
<li>JDK5.0起提供了线程池相关API，ExecutorService和Executors。<ul>
<li> ExecutorService：真正的线程池接口，常见子类ThreadPoolExecutor。</li>
<li> Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="七、常用类"><a href="#七、常用类" class="headerlink" title="七、常用类"></a>七、常用类</h2><ul>
<li>String类：<ul>
<li>String是一个final类，不可被继承。</li>
<li>String实现了Serializable接口：表示String是支持序列化的。</li>
<li>String实现了Comparable接口：表示String可以比较大小。</li>
<li>String内部定义了final char[] value用于存储字符串数据。</li>
<li>String代表不可变的字符序列，简称不可变性。体现如下：<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新制定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当调用String的replace方法修改指定字符或者字符串时，也需要重新制定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
</li>
<li>通过字面量的方式(区别于new)给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li>
<li>字符串常量池中不会存储相同内容的字符串。</li>
<li>常量和常量的拼接结果在常量池，且常量池中不会存在相同的常量。</li>
<li>如果拼接的结果调用intern方法，结构就在堆中。</li>
<li>只要其中有一个是变量，结果就在堆中。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U5c2b7f2ebb314b978d91c042c315a5aeR.jpg" alt="image-20210510211314930" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>String中的方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int length()</td>
<td>长度</td>
</tr>
<tr>
<td>char charAt(int index)</td>
<td>索引处字符</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>是否为空</td>
</tr>
<tr>
<td>String toLowerCase()</td>
<td>转为小写</td>
</tr>
<tr>
<td>String toUpperCase()</td>
<td>转为大写</td>
</tr>
<tr>
<td>String trim</td>
<td>忽略开头结尾空白</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>比较是否相等</td>
</tr>
<tr>
<td>boolean equalsIgnoreCase(String anotherString)</td>
<td>忽略大小写比较相等</td>
</tr>
<tr>
<td>String concat(String str)</td>
<td>拼接末尾</td>
</tr>
<tr>
<td>int compareTo(String anotherString)</td>
<td>比较字符串大小</td>
</tr>
<tr>
<td>String substring(int beginIndex)</td>
<td>截取</td>
</tr>
<tr>
<td>String substring(int beginIndex, int endIndex)</td>
<td>截取指定位置</td>
</tr>
<tr>
<td>boolean contains(charSequence s)</td>
<td>是否包含</td>
</tr>
<tr>
<td>int indexOf(String str)</td>
<td>字符串第一次出现的位置</td>
</tr>
<tr>
<td>String replace(char oldChar, newChar)</td>
<td>替换字符</td>
</tr>
<tr>
<td>String matches(String regex)</td>
<td>检查是否匹配给定的正则表达式</td>
</tr>
</tbody></table>
<ul>
<li>String、StringBuffer、StringBuilder三者的异同：<ul>
<li>String：不可变的字符序列，底层使用char[]存储。</li>
<li>StringBuffer：可变的字符序列，线程安全，效率低，底层使用char存储。</li>
<li>StringBuilder：可变的字符序列，JDK5新增的，线程不安全，效率高，底层使用char[]存储。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U10d4639021654092b1d930a11f75eaaet.jpg" alt="image-20210511151535634" style="zoom:80%;" />

<ul>
<li>以StringBuffer为例：<ul>
<li>StringBuffer()：初始容量为16的字符串缓冲区。</li>
<li>StringBuffer(int capacity)：指定长度，如果将来长度不够，默认情况下，扩容为原来容量的2倍加2，同时将原有数组的元素复制到新的数组中。</li>
<li>StringBuffer的常用方法：<ul>
<li><code>StringBuffer append(xxx)</code>：提供了很多的append()方法，用于进行字符串拼接。</li>
<li><code>StringBuffer delete(int start,int end)</code>：删除指定位置的内容。</li>
<li><code>StringBuffer replace(int start, int end, String str)</code>：把[start,end)位置替换为str。</li>
<li><code>StringBuffer insert(int offset, xxx)</code>：在指定位置插入xxx。</li>
<li><code>StringBuffer reverse()</code>：把当前字符序列逆转。</li>
<li><code>public int indexOf(String str)</code>。</li>
<li><code>public String substring(int start,int end)</code>。</li>
<li><code>public int length()</code>。</li>
<li><code>public char charAt(int n)</code>。</li>
<li><code>public void setCharAt(int n ,char ch)</code>。</li>
</ul>
</li>
</ul>
</li>
<li>Math类：abs、三角函数(acos、asin、atan、cos…)、sqrt、pow、log、exp、max、min、random、round等。</li>
<li>BigInteger(String val)、 BigDecimal(String val)来使用高精度整数和小数。</li>
<li>System类：<ul>
<li>该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</li>
<li>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li>
</ul>
</li>
<li>JDK8之前的日期和时间API：<ul>
<li>System类中的currentTimeMillis()。</li>
<li>java.util.Date类(其中有java.sql.Date的子类)：<ul>
<li>构造器：Date()默认为当前时间、Date(指定毫秒数)。</li>
<li>方法：toSting显示当前的年月日时分秒、getTime获取当前Date对象对应的毫秒数(时间戳)。</li>
</ul>
</li>
<li>java.text.SimpleDateFormat类：不与语言环境有关的方式格式化和解析日期的具体类。</li>
<li>java.util.calendar(日历)类：完成日期字段之间互相操作的功能。</li>
</ul>
</li>
<li>JDK8新出现的日期和时间API：<ul>
<li>LocalDate、LocalTime、LocalDateTime类的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。</li>
<li>Instant(瞬时)：时间线上的一个瞬时点。</li>
</ul>
</li>
<li>Java实现对象排序的方式有两种：<ul>
<li>自然排序：java.lang.Comparable。<ul>
<li>像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象的方法。</li>
<li>重写compareTo的规则：当前对象this大于形参对象，返回正整数；相等返回0；反之返回负整数。</li>
<li>对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。</li>
<li>一但确定，在任何位置都可以比较大小。</li>
</ul>
</li>
<li>定制排序：java.lang.Comparable。<ul>
<li>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator 的对象来排序，强行对多个对象进行整体排序的比较。</li>
<li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
<li>可以将Comparator传递给sort方法(如Collections.sort、Arrays.sort)， 从而允许在排序顺序上实现精确控制。</li>
<li>还可以使用Comparator来控制某些数据结构(如有序set或有序映射)的顺序，或者为那些没有自然顺序的对象Collection提供排序。</li>
<li>java.util.Comparator属于临时性比较。</li>
</ul>
</li>
</ul>
</li>
<li>java.lang.Comparable示例如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U8972676e9e0b414fb742043d83e08cd5J.jpg" alt="image-20210510214317549" style="zoom:80%;" />

<ul>
<li>java.lang.Comparable示例如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U74eb8bbddaef40b898932d95655a27a39.jpg" alt="image-20210510215723326" style="zoom:80%;" />

<h2 id="八、IO流"><a href="#八、IO流" class="headerlink" title="八、IO流"></a>八、IO流</h2><ul>
<li>java.io.File类：<ul>
<li>文件和文件目录路径的抽象表示形式，与平台无关。</li>
<li>File能新建、删除、重命名文件和目录，但File不能访问文件内容本身。</li>
<li>如果需要访问文件内容本身，则需要使用输入/输出流。</li>
<li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li>
<li>File对象可以作为参数传递给流的构造器</li>
</ul>
</li>
<li>路径分隔符和系统有关：<ul>
<li>windows和DOS系统默认使用<code>\</code>来表示。</li>
<li>UNIX和URL使用<code>/</code>来表示。</li>
<li>Java程序支持跨平台运行，因此路径分隔符要慎用。</li>
<li>File类提供了一个常量：<code>public static final String separator</code>代表分隔符。</li>
</ul>
</li>
<li>流的分类：<ul>
<li>按操作数据单位不同分为：字节流(8bit)，字符流(16bit)。</li>
<li>按数据流的流向不同分为：输入流，输出流。</li>
<li>按流的角色的不同分为：节点流，处理流。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U1d9f99f3f843455bb5c20557276d37dcf.jpg" alt="image-20210511152210251" style="zoom:50%;" />

<ul>
<li>步骤：<ul>
<li>File类的实例化。</li>
<li>FileReader流的实例化。</li>
<li>读入操作。</li>
<li>资源关闭。</li>
</ul>
</li>
</ul>
<h2 id="九、枚举类与注解"><a href="#九、枚举类与注解" class="headerlink" title="九、枚举类与注解"></a>九、枚举类与注解</h2><ul>
<li>枚举类：一组常量通常使用枚举类，如果枚举类中只有一个对象，则可以作为单例模式的实现方式。</li>
<li>在JDK5之前，自定义枚举类；在JDK5之后，可以通过enum关键字定义枚举类。</li>
<li>自定义枚举类如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U160eba9a74614321a60d225667d5b5435.jpg" alt="image-20210511153323863" style="zoom:80%;" />

<ul>
<li>enum关键字如下。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Uc712b145df00407b85714e7994e20f1cS.jpg" alt="image-20210511153343577" style="zoom:80%;" />

<ul>
<li>enum添加接口：<ul>
<li>实现接口，在enum类中实现接口方法。</li>
<li>让枚举类的对象分别实现接口中的抽象方法。</li>
</ul>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Ubd4520a99e0244f8ab1cdca8335b0c74P.jpg" alt="image-20210511153729939" style="zoom:80%;" />

<ul>
<li><p>enum类中的常用方法：</p>
<ul>
<li><code>values()</code>：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li>
<li><code>valueOf(String str)</code>：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常： IllegalArgumentException。</li>
<li><code>toString()</code>：返回当前枚举类对象常量的名称。</li>
</ul>
</li>
<li><p>注解：Annotation可以像修饰符一样被使用, 可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。框架=注解+反射+设计模式。</p>
</li>
<li><p><code>@Override</code>：限定重写父类方法, 该注解只能用于方法。</p>
</li>
<li><p><code>@Deprecated</code>：用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择。</p>
</li>
<li><p><code>@SuppressWarnings</code>：抑制编译器警告。</p>
</li>
</ul>
<h2 id="十、泛型"><a href="#十、泛型" class="headerlink" title="十、泛型"></a>十、泛型</h2><ul>
<li>泛型的类型必须是类，不能是基本数据类型，如果有需要用到基本数据类型的位置，需要拿包装类来替换。</li>
<li>如果实例化时没有指明泛型的类型。则默认为java.lang.Object类型。</li>
</ul>
<img src="https://ae01.alicdn.com/kf/Ud6c658e62c90462f82cb1c6057853894q.jpg" alt="image-20210511154917492" style="zoom:80%;" />

<ul>
<li><p>泛型的构造器如下：<code>public classname() &#123;&#125;</code>。</p>
</li>
<li><p>静态方法不能使用类的泛型。</p>
</li>
<li><p>不能使用new E[]，但是可以使用<code>E[] elements = (E[]) new Object[capacity]</code>。</p>
</li>
<li><p>异常类不能使用泛型。</p>
</li>
<li><p>通配符：<code>G&lt;?&gt;</code>，对于其不能添加数据，null除外，读取的数据类型为Object。</p>
</li>
<li><p><code>? extends A</code>：A和A的子类。</p>
</li>
<li><p><code>? super A</code>：A和A的父类。</p>
</li>
<li><p><code>? extends Comparable</code>：只允许泛型为实现Comparable接口的实现类的引用调用。</p>
</li>
<li><p>A是B的父类，但是<code>G&lt;A&gt;</code>和<code>G&lt;B&gt;</code>不具备父子关系，二者为并列关系，<code>A&lt;G&gt;</code>是<code>B&lt;G&gt;</code>的父类。</p>
</li>
<li><p>泛型的方法如下。</p>
</li>
</ul>
<img src="https://ae01.alicdn.com/kf/U912dae55181043f3a77203c620eec7f0q.jpg" alt="image-20210511155846375" style="zoom:80%;" />

<ul>
<li>泛型方法可以声明为静态的，因为泛型参数是在调用时确定而非在实例化时确定。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/05/06/Java%E5%9F%BA%E7%A1%80%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AE%8B%E7%BA%A2%E5%BA%B7-Summary-for-videos/">http://example.com/2021/05/06/Java%E5%9F%BA%E7%A1%80%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AE%8B%E7%BA%A2%E5%BA%B7-Summary-for-videos/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://ae01.alicdn.com/kf/Ue5edb0f19a2e4271ae53123db8ea53e8N.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%AC%E4%BA%8C%E7%AB%A0%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82-Summary-after-reading/"><img class="prev-cover" src="https://ae01.alicdn.com/kf/U17ea5ef5f37b49b5b968d0dac77d9905A.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">计算机网络自顶向下方法第二章——应用层 Summary after reading</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/05/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"><img class="next-cover" src="https://ae01.alicdn.com/kf/U8638e8e48eeb420995874eb927e4228fC.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">最短编辑距离</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">69</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">53</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AE%8B%E7%BA%A2%E5%BA%B7"><span class="toc-text">Java基础全套教程[尚硅谷宋红康]</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">一、基础语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95"><span class="toc-text">二、数组语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">三、面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">四、设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">五、异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">六、多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">七、常用类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81IO%E6%B5%81"><span class="toc-text">八、IO流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3"><span class="toc-text">九、枚举类与注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">十、泛型</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/12/hello-world/" title="Hello World"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2021/07/12/hello-world/" title="Hello World">Hello World</a><time datetime="2021-07-12T03:21:34.585Z" title="Created 2021-07-12 11:21:34">2021-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/07/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0-Java%E8%99%9A%E6%8B%9F%E6%9C%BA-jvm/" title="[面试复习]Java虚拟机(jvm)"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[面试复习]Java虚拟机(jvm)"/></a><div class="content"><a class="title" href="/2021/06/07/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0-Java%E8%99%9A%E6%8B%9F%E6%9C%BA-jvm/" title="[面试复习]Java虚拟机(jvm)">[面试复习]Java虚拟机(jvm)</a><time datetime="2021-06-07T02:03:23.000Z" title="Created 2021-06-07 10:03:23">2021-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/31/%E4%BB%80%E4%B9%88%E6%98%AFBSD%E5%8D%8F%E8%AE%AE%EF%BC%9F/" title="什么是BSD协议？"><img src="https://pic.imgdb.cn/item/60b46f1139f6859bc20e2507.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="什么是BSD协议？"/></a><div class="content"><a class="title" href="/2021/05/31/%E4%BB%80%E4%B9%88%E6%98%AFBSD%E5%8D%8F%E8%AE%AE%EF%BC%9F/" title="什么是BSD协议？">什么是BSD协议？</a><time datetime="2021-05-31T05:07:11.000Z" title="Created 2021-05-31 13:07:11">2021-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/29/SSM%E2%80%94%E2%80%94SpringMVC-1/" title="SSM——SpringMVC(1)"><img src="https://pic.imgdb.cn/item/60b1767e08f74bc1596a7232.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSM——SpringMVC(1)"/></a><div class="content"><a class="title" href="/2021/05/29/SSM%E2%80%94%E2%80%94SpringMVC-1/" title="SSM——SpringMVC(1)">SSM——SpringMVC(1)</a><time datetime="2021-05-28T22:59:42.000Z" title="Created 2021-05-29 06:59:42">2021-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/28/SSM%E2%80%94%E2%80%94Spring-2/" title="SSM——Spring(2)"><img src="https://pic.imgdb.cn/item/60b0aade08f74bc159eaa6ab.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSM——Spring(2)"/></a><div class="content"><a class="title" href="/2021/05/28/SSM%E2%80%94%E2%80%94Spring-2/" title="SSM——Spring(2)">SSM——Spring(2)</a><time datetime="2021-05-28T06:10:47.000Z" title="Created 2021-05-28 14:10:47">2021-05-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
                        function gitcalendar_injector_config(){
                          var parent_div_git = document.getElementById('recent-posts');
                          var item_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
                          parent_div_git.insertAdjacentHTML("afterbegin",item_html)
                          console.log('已挂载gitcalendar')
                          }

                        if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
                            gitcalendar_injector_config()
                            GitCalendarInit("https://gitcalendar.akilar.top/api?fujang233",['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c'],'fujang233')
                        }
                      </script><!-- hexo injector body_end end --></body></html>